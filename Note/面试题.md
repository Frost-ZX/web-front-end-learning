<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="./assets/style.css">
<link rel="stylesheet" href="./assets/random-question.css">
<script src="./assets/script.js"></script>
<script src="./assets/random-question.js"></script>
<div class="contents"></div>

## 面试题

- [面试题](#面试题)
- [---](#)
- [2021-02-26](#2021-02-26)
    - [JavaScript 原型、原型链是什么？有什么特点？](#javascript-原型-原型链是什么-有什么特点)
    - [MVVM 和 MVC 的全称？区别是什么？](#mvvm-和-mvc-的全称-区别是什么)
    - [Vue 请求接口—般放在哪个生命周期中？](#vue-请求接口-般放在哪个生命周期中)
    - [Vue 路由模式 hash 和 history 的区别？](#vue-路由模式-hash-和-history-的区别)
- [2021-02-04](#2021-02-04)
    - [面向对象编程（OOP）](#面向对象编程-oop)
    - [MySQL 表常用存储引擎](#mysql-表常用存储引擎)
- [2021-02-03](#2021-02-03)
    - [Promise](#promise)
    - [Git 状态撤销](#git-状态撤销)
- [2021-02-02](#2021-02-02)
    - [cookie、session、token](#cookie-session-token)
    - [HTTP 请求类型](#http-请求类型)
- [2021-01-28](#2021-01-28)
    - [渐进增强和优雅降级](#渐进增强和优雅降级)
    - [CSS 的重绘和回流](#css-的重绘和回流)
- [2021-01-27](#2021-01-27)
    - [函数节流和函数防抖](#函数节流和函数防抖)
- [2021-01-26](#2021-01-26)
    - [判断变量 arr 是否为数组](#判断变量-arr-是否为数组)
- [2021-01-16](#2021-01-16)
    - [什么是外边距重叠？重叠的结果是什么？](#什么是外边距重叠-重叠的结果是什么)
- [2021-01-15](#2021-01-15)
    - [简述 Vue 路由的 beforeEach 钩子函数的参数](#简述-vue-路由的-beforeeach-钩子函数的参数)
    - [对 keep-alive 的了解](#对-keep-alive-的了解)
    - [什么是 Vue？Vue 的特点？](#什么是-vue-vue-的特点)
    - [框架和库的区别](#框架和库的区别)
    - [一个 CSS 文件如果过大的话，加载会很慢，占用过大带宽，如果解决？](#一个-css-文件如果过大的话-加载会很慢-占用过大带宽-如果解决)
- [2021-01-14](#2021-01-14)
    - [VueX 的作用](#vuex-的作用)
    - [Vue 中的路由拦截器的作用](#vue-中的路由拦截器的作用)
    - [列举 HTTP 请求中常见的请求方式](#列举-http-请求中常见的请求方式)
    - [对于 MVVM 的理解](#对于-mvvm-的理解)
    - [Vue 的生命周期](#vue-的生命周期)
- [2021-01-13](#2021-01-13)
    - [axios 的特点](#axios-的特点)
    - [Vue 路由 `params` 和 `query` 传参的区别](#vue-路由-params-和-query-传参的区别)
    - [JavaScript 常用的继承方式](#javascript-常用的继承方式)
- [2021-01-12](#2021-01-12)
    - [引进组件的步骤](#引进组件的步骤)
    - [`delete` 和 `Vue.delete()` 删除数组元素的区别](#delete-和-vue-delete-删除数组元素的区别)
    - [SPA 首屏加载慢如何解决](#spa-首屏加载慢如何解决)
    - [Vue Router 跳转和 location.href 有什么区别](#vue-router-跳转和-location-href-有什么区别)
    - [Vue 的 `router-link` 在 PC 上有用，但在 Android 上没反应，如何解决？](#vue-的-router-link-在-pc-上有用-但在-android-上没反应-如何解决)
- [2021-01-09](#2021-01-09)
    - [简述 Vue `computed` 和 `watch` 的使用场景](#简述-vue-computed-和-watch-的使用场景)
    - [`v-if` 和 `v-for` 的优先级](#v-if-和-v-for-的优先级)
    - [Vue 常用的修饰符](#vue-常用的修饰符)
    - [Vue 的两个核心点](#vue-的两个核心点)
    - [Vue 和 jQuery 的区别](#vue-和-jquery-的区别)
    - [同源策略](#同源策略)
    - [HTML5 的离线存储](#html5-的离线存储)
    - [`spilt()` 和 `join()` 的区别](#spilt-和-join-的区别)
    - [列举常用的 BOM 对象和常用的 window 对象方法](#列举常用的-bom-对象和常用的-window-对象方法)
    - [Ajax 的最大特点](#ajax-的最大特点)
    - [常见的 HTTP 状态码？分别是什么意思？](#常见的-http-状态码-分别是什么意思)
    - [在循环中，break 和 continue 语句的功能有何不同？](#在循环中-break-和-continue-语句的功能有何不同)
    - [`==` 和 `===` 的不同](#和-的不同)
- [2021-01-08](#2021-01-08)
    - [Vue `$nextTick()` 的使用](#vue-nexttick-的使用)
    - [Vue 组件的 `data` 为什么要用函数？](#vue-组件的-data-为什么要用函数)
    - [Vue 是如何实现双向数据绑定的？](#vue-是如何实现双向数据绑定的)
    - [单页面应用和多页面应用区别及优缺点](#单页面应用和多页面应用区别及优缺点)
- [2021-01-07](#2021-01-07)
    - [Vue `<keep-alive></keep-alive>` 的作用是什么？](#vue-keep-alive-keep-alive-的作用是什么)
    - [Vue 如何获取 DOM？](#vue-如何获取-dom)
    - [Vue 常用指令及其用法](#vue-常用指令及其用法)
    - [`vue-loader` 是什么？它的用途有哪些？](#vue-loader-是什么-它的用途有哪些)
    - [Vue 为什么要使用 key 属性？](#vue-为什么要使用-key-属性)
- [2021-01-06](#2021-01-06)
    - [Vue 的优点](#vue-的优点)
    - [Vue 父组件如何向子组件传递数据](#vue-父组件如何向子组件传递数据)
    - [Vue 子组件如何调用父组件事件](#vue-子组件如何调用父组件事件)
    - [Vue 中 `v-show` 和 `v-if` 指令的共同点和不同点](#vue-中-v-show-和-v-if-指令的共同点和不同点)
    - [数组和对象有哪些原生方法？](#数组和对象有哪些原生方法)
    - [JavaScript 如何实现 JavaScript 对象的继承？](#javascript-如何实现-javascript-对象的继承)
    - [JavaScript 中会被隐式转换为 false 的值](#javascript-中会被隐式转换为-false-的值)
- [2021-01-05](#2021-01-05)
    - [解析 URL 地址的参数（?=...）为一个对象](#解析-url-地址的参数-为一个对象)
    - [vue-router 传参方式及区别](#vue-router-传参方式及区别)
    - [Promise 的基本用法和原理](#promise-的基本用法和原理)
    - [将数组 `var arr = ['This', 'is', 'Baidu', 'Campus']` 变为 `This is Baidu Campus`](#将数组-var-arr-this-is-baidu-campus-变为-this-is-baidu-campus)
    - [已知有字符串 `get-element-by-id`，写一个 function 将其转化成驼峰表示法 `getElementById`](#已知有字符串-get-element-by-id-写一个-function-将其转化成驼峰表示法-getelementbyid)
    - [对数组 `var arr = [3, 6, 2, 4, 1, 5]` 进行下列操作](#对数组-var-arr-3-6-2-4-1-5-进行下列操作)
    - [以 `YYYY-MM-DD` 的方式输出今天的日期（例如 2014 年 9 月 26 日输出 2014-09-26）](#以-yyyy-mm-dd-的方式输出今天的日期-例如-2014-年-9-月-26-日输出-2014-09-26)
- [2020-12-31](#2020-12-31)
    - [正则表达式构造函数 `new RegExp()` 与正则表达字面量 `var reg = /.../` 有什么不同？匹配邮箱的正则表达式是？](#正则表达式构造函数-new-regexp-与正则表达字面量-var-reg-有什么不同-匹配邮箱的正则表达式是)
    - [列举 DOM 常用的查找节点的方法](#列举-dom-常用的查找节点的方法)
    - [简述 Vue 的生命周期](#简述-vue-的生命周期)
- [2020-12-29](#2020-12-29)
    - [事件绑定和普通事件（事件监听）有什么区别？](#事件绑定和普通事件-事件监听-有什么区别)
    - [Vue 组件的数据通信方式](#vue-组件的数据通信方式)
- [2020-12-28](#2020-12-28)
    - [`call` 和 `apply` 的区别是什么？](#call-和-apply-的区别是什么)
    - [简述 Sass 和 Less，以及区别](#简述-sass-和-less-以及区别)
    - [JavaScript 原型、原型链是什么，有什么特点？](#javascript-原型-原型链是什么-有什么特点-1)
- [2020-12-25](#2020-12-25)
    - [如何获取对象 obj 拥有的所有属性（可枚举的、不可枚举的，不包括继承来的属性）](#如何获取对象-obj-拥有的所有属性-可枚举的-不可枚举的-不包括继承来的属性)
- [2020-12-24](#2020-12-24)
    - [JavaScript 的 this、作用域](#javascript-的-this-作用域)
    - [闭包是什么？有什么特性？对页面有什么影响？](#闭包是什么-有什么特性-对页面有什么影响)
    - [Vue 如何更新数组数据、对象数据？](#vue-如何更新数组数据-对象数据)
- [2020-12-21](#2020-12-21)
    - [cookies、sessionStorage 和 localStorage 的区别](#cookies-sessionstorage-和-localstorage-的区别)
    - [同步和异步的区别？JavaScript 实现异步的方式有哪些？](#同步和异步的区别-javascript-实现异步的方式有哪些)
- [2020-12-17](#2020-12-17)
    - [`instanceof` 和 `typeof` 怎么用？有什么区别？](#instanceof-和-typeof-怎么用-有什么区别)
    - [ES6 箭头函数与普通函数的区别](#es6-箭头函数与普通函数的区别)
- [2020-12-16](#2020-12-16)
    - [编写一个数组去重的方法](#编写一个数组去重的方法)
    - [边输入边获取 input 输入框的值，用哪个事件比较好？](#边输入边获取-input-输入框的值-用哪个事件比较好)
- [2020-12-15](#2020-12-15)
    - [什么是严格模式？](#什么是严格模式)
    - [严格模式的好处？](#严格模式的好处)
- [2020-12-11](#2020-12-11)
    - [Less、Sass 是什么？大家为什么要使用它们？](#less-sass-是什么-大家为什么要使用它们)
    - [关于事件，IE 与 FireFox 的事件机制有什么区别？](#关于事件-ie-与-firefox-的事件机制有什么区别)
- [2020-12-10](#2020-12-10)
    - [将数字 `12345678` 转化成 RMB 形式（`12,345,678`）](#将数字-12345678-转化成-rmb-形式-12-345-678)
- [2020-12-08](#2020-12-08)
    - [同步和异步的区别](#同步和异步的区别)
- [2020-12-04](#2020-12-04)
    - [去除数组中重复的元素](#去除数组中重复的元素)
- [2020-12-03](#2020-12-03)
    - [JavaScript 中，IE 和标准下有哪些兼容性的写法](#javascript-中-ie-和标准下有哪些兼容性的写法)
    - [获取某个 DOM 对象的非行内样式的函数](#获取某个-dom-对象的非行内样式的函数)
    - [将 `12345678` 变成 `87654321`（反转字符串）](#将-12345678-变成-87654321-反转字符串)
- [2020-12-02](#2020-12-02)
    - [DOM 操作中，查找节点的方法](#dom-操作中-查找节点的方法)
    - [数组方法 `pop()`、`push()`、`shift()`、`unshift()` 的作用](#数组方法-pop-push-shift-unshift-的作用)
    - [判断字符串 `asdfssaaasasasasaa` 中出现次数最多的字符以及出现的次数](#判断字符串-asdfssaaasasasasaa-中出现次数最多的字符以及出现的次数)
- [2020-12-01](#2020-12-01)
    - [获取到页面中所有的 `checkbox` 标签，并把这些 DOM 对象放进数组中](#获取到页面中所有的-checkbox-标签-并把这些-dom-对象放进数组中)
    - [什么时候会出现 `undefined` 值](#什么时候会出现-undefined-值)
- [2020-11-27](#2020-11-27)
    - [对 JSON 的了解](#对-json-的了解)
    - [`document.write` 和 `innerHTML` 的区别](#document-write-和-innerhtml-的区别)
- [2020-11-26](#2020-11-26)
    - [CSS 的 `content` 属性的作用和应用](#css-的-content-属性的作用和应用)
    - [减少页面加载时间的方法](#减少页面加载时间的方法)
    - [`new` 操作符具体做了什么？](#new-操作符具体做了什么)
- [2020-11-25](#2020-11-25)
    - [CSS3 的新特性](#css3-的新特性)
    - [新的 HTML5 文档类型和字符集](#新的-html5-文档类型和字符集)
    - [CSS3 新增伪类](#css3-新增伪类)
- [2020-11-24](#2020-11-24)
    - [`px` 和 `em` 的区别](#px-和-em-的区别)
    - [`foo = foo || bar`，这行代码是什么意思？为什么要这样写？](#foo-foo-bar-这行代码是什么意思-为什么要这样写)
- [2020-11-20](#2020-11-20)
    - [GET 和 POST 的区别？何时使用 POST？](#get-和-post-的区别-何时使用-post)
- [2020-11-19](#2020-11-19)
    - [JSONP 的原理？为什么 JSONP 不是真正的 AJAX？](#jsonp-的原理-为什么-jsonp-不是真正的-ajax)
    - [AJAX 是什么？如何创建一个 AJAX？](#ajax-是什么-如何创建一个-ajax)
    - [简述 AJAX 的过程?](#简述-ajax-的过程)
- [2020-11-18](#2020-11-18)
    - [用 JavaScript 实现随机选取 10-100 之间的 10 个数字，存入一个数组，并排序](#用-javascript-实现随机选取-10-100-之间的-10-个数字-存入一个数组-并排序)
    - [把两个数组合并，并删除第二个元素](#把两个数组合并-并删除第二个元素)
    - [以下代码的执行结果](#以下代码的执行结果)
- [2020-11-17](#2020-11-17)
    - [将字符串 `<tr><td>{$id}</td><td>{$name}</td></tr>` 中的 `{$id}` 替换为 `10`，`{$name}` 替换为 `Tony`](#将字符串-tr-td-id-td-td-name-td-tr-中的-id-替换为-10-name-替换为-tony)
    - [下列代码会输出什么？为什么？](#下列代码会输出什么-为什么)
- [2020-11-13](#2020-11-13)
    - [`call` 和 `apply` 的异同](#call-和-apply-的异同)
- [2020-11-12](#2020-11-12)
    - [JavaScript 的 `typeof` 返回哪些数据类型](#javascript-的-typeof-返回哪些数据类型)
    - [例举 3 种强制类型转换和 2 种隐式类型转换](#例举-3-种强制类型转换和-2-种隐式类型转换)
    - [`split()` 和 `join()` 的区别](#split-和-join-的区别)
- [2020-11-11](#2020-11-11)
    - [原生 JavaScript 的 `window.onload` 与 jQuery 的 `$(document).ready(function () { })` 有什么不同？](#原生-javascript-的-window-onload-与-jquery-的-document-ready-function-有什么不同)
    - [`img` 的 `alt` 与 `title` 的异同？`strong` 与 `em` 的异同?](#img-的-alt-与-title-的异同-strong-与-em-的异同)
    - [网页制作会用到的图片格式](#网页制作会用到的图片格式)
- [2020-11-10](#2020-11-10)
    - [使用 `link` 和 `@import` 引入 CSS 的区别？](#使用-link-和-import-引入-css-的区别)
    - [为什么要 `初始化` 样式？](#为什么要-初始化-样式)
    - [`BFC` 是什么？](#bfc-是什么)
- [2020-11-08](#2020-11-08)
    - [下列 JavaScript 代码执行后，依次 alert() 的结果是？](#下列-javascript-代码执行后-依次-alert-的结果是)
    - [下列 JavaScript 代码的输出结果为？](#下列-javascript-代码的输出结果为)
    - [行内元素（内联元素）和块级元素的具体区别是什么？行内元素的 padding 和 margin 可设置吗？](#行内元素-内联元素-和块级元素的具体区别是什么-行内元素的-padding-和-margin-可设置吗)
- [2020-11-06](#2020-11-06)
    - [有哪几种方式可以直接获取这个 div 的 `DOM 对象` ？如何把 `DOM 对象` 转换为 `jQuery 对象` ？](#有哪几种方式可以直接获取这个-div-的-dom-对象-如何把-dom-对象-转换为-jquery-对象)
    - [原生的 JavaScript 如何显示或隐藏一个 DOM 元素？](#原生的-javascript-如何显示或隐藏一个-dom-元素)
    - [JavaScript 的循环语句有哪些？](#javascript-的循环语句有哪些)
- [2020-11-05](#2020-11-05)
    - [`console.log(8 | 1)` 的输出值](#console-log-8-1-的输出值)
    - [`alert(0.4 * 0.2)` 的结果是多少？和你预期的一样吗？如果不一样怎么解决？](#alert-0-4-0-2-的结果是多少-和你预期的一样吗-如果不一样怎么解决)
- [2020-11-04](#2020-11-04)
    - [如何判断一个 JavaScript 变量是数组类型](#如何判断一个-javascript-变量是数组类型)
- [2020-11-03](#2020-11-03)
    - [简述 `readonly` 与 `disabled` 的区别](#简述-readonly-与-disabled-的区别)
- [2020-11-01](#2020-11-01)
    - [阻止事件冒泡和默认事件的方法](#阻止事件冒泡和默认事件的方法)
    - [添加节点、删除节点、替换节点、插入到某个节点的方法](#添加节点-删除节点-替换节点-插入到某个节点的方法)
- [2020-10-30](#2020-10-30)
    - [CSS 中 `rgba()` 与 `opacity` 的透明效果的区别](#css-中-rgba-与-opacity-的透明效果的区别)
    - [JavaScript 事件委托](#javascript-事件委托)
- [2020-10-29](#2020-10-29)
    - [CSS 的基本语句构成](#css-的基本语句构成)
    - [如何让一个 DOM 节点在被点击时候执行一个函数？](#如何让一个-dom-节点在被点击时候执行一个函数)
    - [简述定义函数的几种方式](#简述定义函数的几种方式)
- [2020-10-24](#2020-10-24)
    - [简述浏览器渲染页面机制](#简述浏览器渲染页面机制)
    - [简述一个完整的 HTTP 事务处理过程](#简述一个完整的-http-事务处理过程)
    - [前端性能优化有哪些？](#前端性能优化有哪些)
- [2020-10-23](#2020-10-23)
    - [`var` 和 `const` 的区别](#var-和-const-的区别)
    - [在 CSS 布局中，什么场景下会出现外边距合并问题？如何解决？](#在-css-布局中-什么场景下会出现外边距合并问题-如何解决)
    - [`break`、`continue`、`return`、`throw` 的作用](#break-continue-return-throw-的作用)
    - [`XSS` 攻击原理与防御](#xss-攻击原理与防御)
- [2020-10-22](#2020-10-22)
    - [在 CSS 布局中，什么场景下出现元素高度塌陷，如何解决元素高度塌陷问题？](#在-css-布局中-什么场景下出现元素高度塌陷-如何解决元素高度塌陷问题)
    - [`display: none` 和 `visibility: hidden` 的区别？](#display-none-和-visibility-hidden-的区别)
    - [CSS 定位有几种，各个定位方式有什么区别？](#css-定位有几种-各个定位方式有什么区别)
    - [JavaScript 原始数据类型有哪些？引用类型数据有哪些？原始数据类型和引用类型的区别?](#javascript-原始数据类型有哪些-引用类型数据有哪些-原始数据类型和引用类型的区别)
- [2020-10-20](#2020-10-20)
    - [对 `盒子模型` 这个概念的理解以及它涉及到的 CSS 属性](#对-盒子模型-这个概念的理解以及它涉及到的-css-属性)
    - [前端页面有哪三层构成，分别是什么？作用是什么？](#前端页面有哪三层构成-分别是什么-作用是什么)

## ---

## 2021-02-26

#### JavaScript 原型、原型链是什么？有什么特点？

每个对象都会在其内部初始化一个属性，就是 prototype（原型）。
当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么就会去 `prototype` 里找这个属性，
这个 `prototype` 又会有自己的 `prototype`，于是就这样一直找下去（原型链）。

关系：
`instance.constructor.prototype = instance.__proto__`

特点：
JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。
修改原型时，与之相关的对象也会继承这一改变。

当需要使用一个属性时，Javascript 引擎会先看当前对象中是否有这个属性。
如果没有，就会查找它的 `prototype` 对象是否有这个属性，如此递推下去，一直检索到 `Object` 内建对象。

#### MVVM 和 MVC 的全称？区别是什么？

MVVM 是 Model-View-ViewModel 的缩写。

MVVM 是一种设计思想：
Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑。
View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。

区别：
都是一种设计思想。
MVC 中的 Controller 演变成 MVVM 中的 ViewModel。
MVVM 主要解决了 MVC 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。
Vue 数据驱动，通过数据来显示视图层，而不是节点操作。

#### Vue 请求接口—般放在哪个生命周期中？

在 `created` 时，视图中的 DOM 并没有被渲染出来，如果此时直接操作 DOM 节点，无法找到相关元素。
在 `mounted` 时，此时的 DOM 元素已经渲染出来了，可以直接操作 DOM 节点。
因此，一般情况下，都放在 `mounted` 中，保证逻辑的统一性。
因为生命周期是同步执行的，AJAX 是异步执行的。
服务端渲染不支持 `mounted` 方法，所以在服务端渲染的情况下一般放在 `created` 中。

#### Vue 路由模式 hash 和 history 的区别？

**hash 模式**

hash 路由模式的 URL 类似 `http://www.example.com/#/xxx`，有 `#` 号，`#` 后面就是 hash 值的变化。
改变 hash 值，它不会向服务器发出请求，因此在切换路由时不会刷新页面。
每次 hash 值发生改变的时候，会触发 `hashchange` 事件，可以通过监听该事件，来知道 hash 值发生了哪些变化。

特点：
URL 类似 `http://www.example.com/#/xxx`，有 `#` 号，不会刷新页面。

**history 模式**

HTML5 的 History API 为浏览器的全局 history 对象增加了该扩展方法。
它是一个浏览器的一个接口，在 window 对象中提供了 `onpopstate` 事件来监听历史栈的改变。
只要历史栈有信息发生改变，就会触发该事件。

特点：
浏览器地址没有 `#`，不会刷新页面，但是 URL 地址会改变。

## 2021-02-04

#### 面向对象编程（OOP）

面向对象编程（OOP）是目前主流的编程范式，核心思想是将需求抽象为对象，然后对其成员进行分析。
对象是一个容器，封装了属性和方法。

**面向对象的三大特性**

- 封装（对象封装属性和方法）
- 继承（原型链继承）
- 多态（根据参数个数不同，返回不同结果）

**构造函数**

构造函数是一个普通函数，习惯以大写字母开头命名，不过构造函数里面引用了 `this`，该 `this` 对象的成员将会被构造函数创建的实例（对象）继承。
每一个构造函数都有一个原型对象（prototype)，一般用于共享原型方法，对象也有原型对象（`__proto__`)， 用于追溯继承其他对象的成员。

**原型链**

- 对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象。
  由于原型本身也是对象，又有自己的原型，所以形成了-条原型链。
  例如：a 对象是 b 对象的原型，b 对象是 c 对象的原型，以此类推。

- 如果一层一层地上溯，所有对象的原型最终都可以上溯到 `object.prototype`（Object 构造函数的 prototype 属性指向的那个对象）
  `Object.prototype` 对象的原型是没有任何属性和方法的 `null` 对象，而 `null` 对象没有自己的原型，因此到 `null` 就终止原型查找。

- 具体原型链图示: http://www.kangliuyong.com/stage2to22

#### MySQL 表常用存储引擎

**InnoDB**

数据表首选存储引擎，支持事务处理，插入和查询速度相对于 MyISAM、Memory 低一些，重启 MySQL 不会丢失数据。

**MyISAM**

拥有较高的插入和查询速度，但不支持事务处理，重启 MySQL 不会丢失数据。

**Memory**

所有数据都保存在内存的存储引擎，拥有极高的插入、更新和查询效率，但不支持事务处理，并且占用和数据量成正比的内存空间，重启 MySQL 会丢失数据。

## 2021-02-03

#### Promise

Promise 是异步编程的一种解决方案。
Promise 方案可以增强回调函数的可读性，可以更友好地处理回调地狱问题。
Promise 对象代表一个异步操作，有三种状态：`pending`（进行中）、`resolved`（已成功）和 `rejected`（已失败）。
Promise 对象的状态不受外界影响，一旦状态改变，就不会再变，任何时候都可以得到这个结果。
Promise 对象的状态改变只有两种可能：从 `pending` 变为 `resolved` 和从 `pending` 变为 `rejected`。
当存在多个异步任务执行时，需要等待所有异步任务都执行完毕后，再执行其他任务，这时可以使用 `Promise. a1l()` 处理。

#### Git 状态撤销

- 已修改，未暂存
  如果只是在编辑器里修改了文件，但还没有执行 `git add`，这时文件还在工作区，并没有进入暂存区，执行 `git reset --hard` 进行撤销操作。

- 已暂存，未提交
  执行了 `git add`， 但还没有执行 `git commit`，这时想要撤销，分别执行 `git reset` 和 `git reset --hard`。
  `git reset` 只是把修改退回到了 `git add` 之前的状态（文件本身还处于已修改未暂存状态），如果想退回未修改状态，还需要执行 `git reset --hard`。

- 已提交，未推送
  既执行了 `git add`， 又执行了 `git commit`，这时代码已经进入了本地仓库，可以执行 `git reset --hard origin/分支名称`。
  例如：`git reset --hard origin/master`

- 已推送
  既执行了 `git add`， 又执行了 `git commit`，且执行了 `git push`，这时代码已经进入远程仓库，可以分别执行 `git reset --hard HEAD` 和 `git push -f`。

## 2021-02-02

#### cookie、session、token

**cookie**

cookie 数据存放在客户的浏览器上，适合保存一些不太重要的信息（例如手机号）。
cookie 不是很安全，别人可以分析存放在本地的 cookie 并进行 cookie 欺骗。

**session**

session 数据临时放在服务器上，至少这点安全性比 cookie 好。
session 会在一定时间内保存在服务器上，当访问增多，会比较占用服务器的性能。
如果 Web 服务器实现负载均衡，下一个操作请求到另一台服务器时 session 会丢失（可能需要重新登录）。
session 适合存储加密后的帐号和密码。

**token**

token 一般用于验证身份，token 是一串加密字符串。
token 用得最多场景是记住账号登录状态。
cookie 和 session 都可以实现类似的功能，但是都没 token 安全，cookie 和 session 都需要发出加密后的密码，虽然密码都加密了但是被公布出来始终还是不安全，使用token 认证不需要直接去操作用户的帐号和密码。
作为身份认证，token 安全性比 session 好，因为每个请求必须携带 token 签名。

#### HTTP 请求类型

HTTP（超文本传输协议）是一种无状态的协议，每次请求必须重新发送数据给服务器，尽管是相同的请求。

- `HTTP/0.9` 只支持 `GET` 请求
- `HTTP/1.0` 支持 `GET`、`POST`、`HEAD` 请求
- `HTTP/1.1` 支持 `GET`、`POST`、`HEAD`、`OPTIONS`、`PUT`、`DELETE`、`TRACE`、`CONNECT` 请求
- `HTTP/2` 是最新发布的版本，通过支持请求与相应的多路重用来减少延迟，通过压缩 HTTP 头字段将协议开销降到最低，同时增加了对请求优先级和服务器端推送的支持。

实际开发中，绝大多情况下使用 `GET` 和 `POST` 请求。

- `GET` 请求一般用于数据的读取。
- `HEAD` 请求与 `GET` 请求一致，但服务器在响应 `HEAD` 请求时不会回传资源的内容部分。
- `POST` 请求用于添加或者修改数据。
- `PUT` 请求用于更新修改数据。
- `DELETE` 请求用于删除数据。
- `CONNECT` 请求是 `HTTP/1.1` 协议预留的，能够将连接改为管道方式的代理服务器，通常用于 SSL 加密服务器的链接与非加密的 HTTP 代理服务器的通信。
- `OPTIONS` 请求与 `HEAD` 请求类似，用于服务器嗅探，以判断是否有对指定资源的访问权限。
- `TRACE` 请求主要用于 HTTP 请求的测试或诊断，与 `PUT` 请求类似，同样用于资源的更新。
  `TRACE` 请求一般用于资源的部分更新，而 `PUT` 请求一般用于资源的整体更新。
  当资源不存在时，`TRACE` 请求会创建个新的资源，而 `PUT` 请求只会对已在资源进行更新。

## 2021-01-28

#### 渐进增强和优雅降级

**渐进增强**

针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。

**优雅降级**

一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

#### CSS 的重绘和回流

**CSS 重绘**

当页面的元素需要更新属性，新的属性对元素的外观，风格的产生影响，这个更新的过程称为重绘。
例如：设置元素的 `background`、`color` 等等，都会重绘元素。

**CSS 回流**

当页面的元素因为尺寸，位置、布局，隐藏等改变而需要浏览器重新构建的过程，这个重构的过程称为回流。
例如：设置元素的 `position`、`float`、`width`、`height` 等等，都会回流元素。

## 2021-01-27

#### 函数节流和函数防抖

**函数节流**

限制一个函数在一定时间内只能执行一次。

**函数防抖**

触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行的等待时间。

**函数防抖使用场景**

- 实时搜索（例如：`oninput` 事件）
- 改变窗口大小（例如 `onresize` 事件）
- 滚动（例如：`onscroll`）

## 2021-01-26

#### 判断变量 arr 是否为数组

```javascript
arr.constructor === Array
arr instanceof Array
Array.isArray(arr)
Array.prototype.isPrototypeOf(arr)
Object.getPrototypeOf(arr) === Array.prototype
Object.prototype.toString.call(arr) === '[object Array]'
```

## 2021-01-16

#### 什么是外边距重叠？重叠的结果是什么？

外边距重叠就是 `margin-collapse`。
在 CSS 当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。
这种合并外边距的方式被称为 `折叠`，并且因而所结合成的外边距称为 `折叠外边距`。

折叠结果遵循下列计算规则：

- 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。
- 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。
- 两个外边距一正一负时，折叠结果是两者的相加的和。

## 2021-01-15

#### 简述 Vue 路由的 beforeEach 钩子函数的参数

`to：route`

即将进入的目标路由对象

`from：route`

当前导航正要离开的路由

`next：function`

一定要调用该方法 resolve 这个钩子
执行效果依赖 next() 方法的调用参数
可以控制网页的跳转

#### 对 keep-alive 的了解

`keep-alive` 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。

在 Vue 2.1.0 版本之后，`keep-alive` 新加入了两个属性：`include` 和 `exclude`：

- `include` - 字符串或正则表达式，只有名称匹配的组件会被缓存。
- `exclude` - 字符串或正则表达式，任何名称匹配的组件都不会被缓存。
- `include` 和 `exclude` 的属性允许组件有条件地缓存。
  二者都可以用 `,` 分隔字符串、正则表达式、数组。
  属性值未正则或数组时，需要使用 `v-bind`。

#### 什么是 Vue？Vue 的特点？

Vue 是一套用于构建用户界面的渐进式框架。
与其他大型框架不同，Vue 被设计为可以自底向上逐层应用，其核心库只关心视图层，便于与第三方库或既有项目整合。

特点：

- 简洁 
- 轻量 
- 快速 
- 数据驱动 
- 模块友好 
- 组件化

#### 框架和库的区别

**框架**

会基于自身的特点为用户提供一整套的解决方案，可以基于它所创造的规则和范例快速实现应用，前提是必须按照它的规则来写。

**库**

是代码集合成的一个产品，怎么应用怎么架构，项目的目录都是由程序员决定。

#### 一个 CSS 文件如果过大的话，加载会很慢，占用过大带宽，如果解决？

- 将 CSS 文件拆分为多个 CSS 文件
- 压缩 CSS
- 去取冗余的样式
- 减少 CSS 选择器层级

## 2021-01-14

#### VueX 的作用

VueX 是一个专门为 Vue.js 应用程序开发的状态管理模式
VueX 可以帮助我们管理共享状态（管理全局变量）。

**VueX 的几个核心概念**

VueX 使用一个 store 对象管理应用的状态，一个 store 包括：`state`、`getter`、`mutation`、`action` 四个属性

**state**：`state` 意为“状态”，是 VueX 状态管理的数据源。

**getter**：`getter` 的作用与 `filters` 有一些相似，可以将 `state` 进行过滤后输出。

**mutation**：`mutation` 是 VueX 中改变 `state` 的唯一途径，并且只能进行同步操作。

**action**：一些对 `state` 进行的异步操作可以放在 `action` 中，并通过在 `action` 提交（`commit`）`mutaion` 变更状态。

**module**：当 `store` 对象过于庞大时，可以根据具体的业务需求分为多个 `module`。

可以在组件中触发 `Action`，`Action` 则会提交 `Mutation`，`Mutaion` 会对 `State` 进行修改，组件再根据 `State`、`Getter` 渲染页面。

#### Vue 中的路由拦截器的作用

路由拦截，权限设置。

**例如**

当用户没有登录权限的时候就会跳转到登录页面（用到的字段：`requireAuth: true`）

#### 列举 HTTP 请求中常见的请求方式

**GET**

向特定的路径资源发出请求，数据暴露在 URL 中。

**POST**

向指定路径资源提交数据进行处理请求，数据包含在请求体中。

**OPTIONS**

返回服务器针对特定资源所支持的 HTTP 请求方法，允许客户端查看，测试服务器性能。

**HEAD**

向服务器与 GET 请求相一致的响应，响应体不会返回，可以不必传输整个响应内容。

**PUT**

从客户端向服务器端传送的数据取代指定的文档的内容。

**DELETE**

请求服务器删除指定的页面。

**TRACE**

回显服务器收到的请求，主要用于测试或者诊断。

**CONNECT**

HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务。

#### 对于 MVVM 的理解

MVVM 最早由微软提出来，它借鉴了桌面应用程序的 MVC（Model-View-Controller）思想。
MVVM 是 `Model-View-ViewModel` 的缩写：

- `Model` 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑。
- `View` 代表 UI 组件，它负责将数据模型转化成 UI 展现出来。
- `ViewModel` 监听模型数据的改变和控制视图行为、处理用户交互（一个同步 View 和 Model 的对象，连接 Model 和 View）。

`ViewModel` 和 `Model` 实现双向数据绑定。

#### Vue 的生命周期

**Vue 生命周期**

Vue 实例从创建到销毁的过程，就是生命周期。
从开始创建、初始化数据、编译模板、挂载 DOM -> 渲染、更新 -> 渲染、销毁等一系列过程，称之为 Vue 的生命周期。

**Vue 生命周期的作用**

它的生命周期中有多个事件钩子，让我们在控制整个 Vue 实例的过程时更容易形成好的逻辑。

**Vue 生命周期总共有几个阶段**

8个阶段：创建前 / 后、载入前 / 后、更新前 / 后、销毁前 / 销毁后

**Vue 第一次页面加载时会触发的生命周期（钩子函数）**

- beforeCreate
- created
- beforeMount
- mounted

**DOM 渲染在哪个周期中就已经完成**

DOM 渲染在 `mounted` 中就已经完成了。

## 2021-01-13

#### axios 的特点

- 从浏览器中创建 `XMLHttpRequests`
- Node.js 创建 HTTP 请求
- 支持 `Promise API`
- 可拦截请求和响应
- 可取消请求
- 可转换请求数据和响应数据
- 可自动转换为 JSON
- axios 中的发送字段的参数是 `data` 和 `params`，`params` 在请求地址中一起发送，`data` 作为一个请求体进行发送
  （`params` 一般适用于 GET 请求，`data` 一般适用于 POST、PUT 请求）

#### Vue 路由 `params` 和 `query` 传参的区别

**用法**

`query` 要用 `path` 来引入，`params` 要用 `name` 来引入。
接收参数分别是 `this.$route.query.name` 和 `this.$route.params.name`。

**URL 显示**

`query` 更加类似于 AJAX 中的 GET 传参，`params` 则类似于 AJAX 中的 POST。

**注意**

`query` 刷新不会丢失 `query` 中的数据。
`params` 刷新会丢失 `params` 中的数据。

#### JavaScript 常用的继承方式

**类式继承**

子构造函数的原型对象继承父构造函数以及父构造函数的原型

**构造函数式继承**

子构造函数继承父构造函数，不能继承父构造函数的原型

**组合式继承**

类式继承 + 构造函数式继承

**多继承**

子构造函数继承多个父构造函数

## 2021-01-12

#### 引进组件的步骤

1. 在 `template` 中引入组件
2. 在 `script` 的第一行用 `import` 引入组件路径
3. 用 `components` 中添加组件名称

#### `delete` 和 `Vue.delete()` 删除数组元素的区别

`delete` 只是被删除的元素变成了 `empty` / `undefined` 其他的元素的键值（下标）还是不变。
`Vue.delete()` 直接删除了数组元素，改变了数组的键值（下标）。

#### SPA 首屏加载慢如何解决

- 安装动态懒加载所需的插件
- 使用 CDN 资源

#### Vue Router 跳转和 location.href 有什么区别

使用 `location.href = URL` 来跳转，简单方便，但是刷新了页面。
使用 `history.pushState(URL)`，无刷新页面，静态跳转。
使用 Vue Router 的 `router.push(URL)` 来跳转，使用了 `Diff 算法`，实现了按需加载，减少了 DOM 的性能消耗。

> 实际上，使用 `router` 跳转和使用 `history.pushState()` 的差别不大，
> 因为 `Vue Router` 的核心是 `history.pushState()`，尤其是在 `history` 模式下。

#### Vue 的 `router-link` 在 PC 上有用，但在 Android 上没反应，如何解决？

Vue 路由在 Android 上有问题（babel 问题），需要安装 `babel polypill` 插件解决。

## 2021-01-09

#### 简述 Vue `computed` 和 `watch` 的使用场景

**computed**

当一个属性受多个属性影响的时候
例：购物车商品结算

**watch**

当一条数据影响多条数据的时候
例：搜索数据

#### `v-if` 和 `v-for` 的优先级

当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` 更高的优先级（`v-if` 将分别重复运行于每个 `v-for` 循环中）。
因此，不推荐 `v-if` 和 `v-for` 同时使用。
若 `v-if` 和 `v-for` 一起使用，Vue 会自动提示 `v-if` 应该放到外层。

#### Vue 常用的修饰符

**.stop**

等同于 JavaScript 中的 `event.stopPropagation()`，用于阻止事件冒泡。

**.prevent**

等同于 JavaScript 中的 `event.preventDefault()`，阻止默认行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）。

**.capture**

设置为事件捕获

**.self**

只会触发自己范围内的事件，不包含子元素。

**.once**

只会触发一次。

#### Vue 的两个核心点

**数据驱动**

ViewModel，保证数据和视图的一致性。

**组件系统**

应用类 UI 可以看作全部是由组件树构成的。

#### Vue 和 jQuery 的区别

jQuery 使用选择器（`$`）选取 DOM 对象，对其进行赋值、取值、事件绑定等操作，和 JavaScript 的区别只在于可以更方便地选取和操作 DOM 对象，而数据和界面是在一起的，还是依赖 DOM 元素的值。
Vue 则是通过 Vue 对象将数据和 View 完全分离开来了，对数据进行操作不再需要引用相应的 DOM 对象（双向数据绑定，MVVM）。

#### 同源策略

- 同源策略
  - 只能请求来自于 `同一来源`（协议、域名、端口相同）的资源

- 同源策略带来的麻烦
  - AJAX 在不同域名下的请求无法实现
  - 如果想要请求其他来源的 JavaScript 文件或者 JSON 数据，可以通过 `JSONP` 来解决。

#### HTML5 的离线存储

**localStorage**

长期存储数据，浏览器关闭后数据不丢失

**sessionStorage**

数据在浏览器关闭后自动删除

#### `spilt()` 和 `join()` 的区别

`split()`

用于把一个字符串分割为字符串数组

`join()`

用于把数组中的所有元素放入一个字符串

#### 列举常用的 BOM 对象和常用的 window 对象方法

常用 BOM 对象

- window（JavaScript 的最顶层对象，其他的 BOM 对象都是 window 对象的属性）
- document（文档对象）
- history（浏览器访问历史信息）
- location（浏览器当前 URL 信息）
- navigator（浏览器本身信息）
- screen（客户端屏幕信息）

常用方法

- alert()
- confirm()
- prompt()
- open()
- close()

#### Ajax 的最大特点

- 可以实现异步通信效果，实现页面局部刷新，带来更好的用户体验。
- 按需获取数据，节约带宽资源。

#### 常见的 HTTP 状态码？分别是什么意思？

状态码                    | 含义
------                    | ----
200 OK                    | 客户端请求成功
301 Moved Permanently     | 资源（网页等）被永久转移到其它的 URI（今后任何新的请求都应使用新的 URI）
302 Found                 | 资源（网页等）被临时转移到其它的 URI（客户端应继续使用原有的 URI）
400 Bad Request           | 客户端请求有语法错误，不能被服务器理解
403 Forbidden             | 服务器收到请求，但是拒绝提供服务
404 Not Found             | 请求的资源不存在
500 Internal Server Error | 内部服务器错误
503 Server Unavailable    | 服务器暂时不能处理客户端的请求

#### 在循环中，break 和 continue 语句的功能有何不同？

`break` 终止整个循环。
`continue` 终止当次循环，继续下一次循环。

#### `==` 和 `===` 的不同

- `==` 会自动转换类型，`===` 不会自动转换类型。
- `===` 先判断数据类型（如果数据类型不一致，直接返回 `false`），之后再判断值。

## 2021-01-08

#### Vue `$nextTick()` 的使用

在修改了 `data` 的值后立刻获取对应 DOM 元素的值时，可能不能获取到更新后的值，
需要使用 `$nextTick()` 这个回调，等待修改后的 `data` 值渲染更新到 DOM 元素之后再获取。

#### Vue 组件的 `data` 为什么要用函数？

- 一个组件的 `data` 选项必须是一个函数，因此每个实例可以维护一份被返回对象的 `独立` 的拷贝。
  （每次复用组件的时候，都会返回一份新的 `data`，相当于每个组件实例都有自己私有的数据空间）
- 否则，进行操作时可能会影响到其它所有的实例（因为对象是引用类型）。

#### Vue 是如何实现双向数据绑定的？

- Vue 双向数据绑定是通过 `数据劫持` 结合 `发布订阅模式` 的方式来实现的。
- 数据和视图同步，数据发生变化时，视图随之发生改变，视图变化时，数据也随之发生改变。
- 核心：`Object.defineProperty()` 方法，设置 `getter` 和 `setter`。

#### 单页面应用和多页面应用区别及优缺点

**单页面应用（SPA）**

通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 HTML、CSS、JavaScript 等资源文件，
所有的页面内容都包含在这个主页面中，而在开发时会分开写（页面片段），然后在交互的时候由路由程序动态载入，
单页面的页面跳转，仅刷新局部资源（多应用于 PC 端）。

**多页面应用（MPA）**

指一个应用中有多个页面，页面跳转时是整页刷新的。

**单页面的优点**

- 用户体验好，速度快，内容的改变不需要重新加载整个页面（因此对服务器压力较小）
- 前后端分离，页面效果可以比较炫酷（例如切换页面内容时的转场动画）。

**单页面缺点**

- 不利于 SEO，导航不可用，如果一定要导航，需要自行实现前进、后退功能
 （由于是单页面，不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）
- 初次加载时耗时较长
- 页面复杂度较高

## 2021-01-07

#### Vue `<keep-alive></keep-alive>` 的作用是什么？

`keep-alive` 是 Vue 的内置组件，可以使被包含的组件保留状态，或避免重新渲染。

#### Vue 如何获取 DOM？

1. 给 DOM 元素添加属性：`ref="domName"`
2. 获取：`this.$refs.domName`

#### Vue 常用指令及其用法

- `v-model` 双向数据绑定
- `v-bind` 绑定属性
- `v-if`、`v-show` 显示与隐藏
- `v-for` 遍历
- `v-on` 绑定事件，`v-once` 绑定单次事件

#### `vue-loader` 是什么？它的用途有哪些？

Vue 文件的一个加载器，可将 template / script / style 转换为 JavaScript 模块。
用途：JavaScript 可以使用 ES6 语法、style 样式可以使用 Scss 或 Less 语法、template 可以使用 Jade、...

#### Vue 为什么要使用 key 属性？

通过使用 `key` 给每个节点做一个唯一标识，`Diff` 算法就可以正确地识别此节点（主要为了高效地更新虚拟 DOM）。

## 2021-01-06

#### Vue 的优点

**轻量级框架**

只关注视图层，是一个构建数据的视图集合，大小只有几十 kb。

**简单易学**

国人开发，中文文档，不存在语言障碍 ，易于理解和学习。

**双向数据绑定**

保留了 `angular` 的特点，在数据操作方面更为简单。

**组件化**

保留了 `react` 的优点，实现了 HTML 的封装和重用，在构建单页面应用方面有着独特的优势。

**视图，数据，结构分离**

使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作。

**虚拟 DOM**

DOM 操作是非常耗费性能的，不再使用原生的 DOM 操作节点，极大解放 DOM 操作。
（具体操作的还是 DOM，但是换了另一种方式）

**运行速度更快**

与 `react` 相比较，同样是操作虚拟 DOM，Vue 在性能上存在很大的优势。

#### Vue 父组件如何向子组件传递数据

通过 `props`

#### Vue 子组件如何调用父组件事件

通过 `$emit()` 方法

#### Vue 中 `v-show` 和 `v-if` 指令的共同点和不同点

**共同点**

都能控制元素的显示和隐藏

**不同点**

实现的本质方法不同，`v-show` 的本质是通过 CSS 中的 display 属性控制隐藏，只会编译一次；
`v-if` 是动态地在 DOM 树内添加或者删除元素，若初始值为 `false`，就不会编译了，而且 `v-if` 多次进行销毁和创建操作比较消耗性能。

**总结**

如果需要频繁切换某节点，使用 `v-show`（切换开销比较小，初始开销较大）。
如果不需要频繁切换某节点，使用 `v-if`（初始渲染开销较小，切换开销比较大）。

#### 数组和对象有哪些原生方法？

- 数组（Array）

  属性           | 作用
  ----           | ----
  `Array.length` | 获取数组的长度

  方法                     | 作用
  ----                     | ----
  `Array.concat()`         | 连接数组
  `Array.join()`           | 将数组元素连接起来以构建一个字符串
  `Array.pop()`            | 删除并返回数组的最后一个元素
  `Array.push()`           | 向数组的末尾添加元素
  `Array.reverse()`        | 颠倒数组中元素的顺序
  `Array.shift()`          | 将元素移出数组
  `Array.slice()`          | 返回数组的一部分
  `Array.sort()`           | 对数组元素进行排序
  `Array.splice()`         | 插入、删除或替换数组的元素
  `Array.toLocaleString()` | 将数组转换为使用一个特定语言环境的字符串（[MDN][20210106-1]）
  `Array.toString()`       | 将数组转换为字符串
  `Array.unshift()`        | 在数组的头部插入一个元素

- 对象（Object）

  方法                            | 作用
  ----                            | ----
  `Object.hasOwnProperty()`       | 检查属性是否被继承
  `Object.isPrototypeOf()`        | 一个对象是否是另一个对象的原型
  `Object.propertyIsEnumerable()` | 能否通过遍历获取该属性
  `Object.toLocaleString()`       | 返回一个特定语言环境下该对象的字符串表示（[MDN][20210106-2]）
  `Object.toString()`             | 返回一个表示该对象的字符串
  `Object.valueOf()`              | 返回对象的原始值

[20210106-1]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/toLocaleString
[20210106-2]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString

#### JavaScript 如何实现 JavaScript 对象的继承？

> https://www.cnblogs.com/chaixiaozhi/p/8515087.html

- 原型链继承

  - 核心：将父类的实例作为子类的原型
  - 缺点：父类新增原型方法 / 原型属性，子类都能访问到，父类一变其它的都变了

- 构造继承（借助构造函数）
- 组合继承（原型 + 构造）
- 寄生式继承
- 寄生组合继承

#### JavaScript 中会被隐式转换为 false 的值

- `undefined`、`null`、`NaN`、`0`、`空字符串`

## 2021-01-05

#### 解析 URL 地址的参数（?=...）为一个对象

```javascript
function paramToObj(url) {
    var param = url.split('?')[1];
    var paramArr = param.split('&');
    var paramObj = {};

    paramArr.forEach(function (item) {
        var kv = item.split('=');

        paramObj[kv[0]] = kv[1];
    });

    return paramObj;
}
```

#### vue-router 传参方式及区别

- query

  - 通过 URL 传参（GET 方式）
  - 通过 `this.$route.query` 接收

- param

  - 通过路由传参，刷新后会丢失
  - 通过 `this.$route.params` 接收

#### Promise 的基本用法和原理

```javascript
const promise = new Promise(function (resolve, reject) {

  ...

  if (异步操作成功的条件){
      resolve(参数);
  } else {
      reject(参数);
  }
});

promise.then(function(value) {
    // 成功状态的回调函数
}, function(error) {
    // 失败状态的回调函数
});
```

Promise 在新建后就会立即执行（同步），`then()` 方法指定的回调函数将在当前脚本所有同步任务执行完才会执行（异步）。

#### 将数组 `var arr = ['This', 'is', 'Baidu', 'Campus']` 变为 `This is Baidu Campus`

```javascript
arr.join(' ')
```

#### 已知有字符串 `get-element-by-id`，写一个 function 将其转化成驼峰表示法 `getElementById`

```javascript
function combo(str){
  var arr = str.split('-');
  for (var i = 1; i < arr.length; i++) {
    arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substr(1);
  }
  str = arr.join("");
  return str;
}
```

#### 对数组 `var arr = [3, 6, 2, 4, 1, 5]` 进行下列操作

- 进行倒排，输出 `[5, 1, 4, 2, 6, 3]`

  ```javascript
  arr.reverse();
  ```

- 进行降序排列，输出 `[6, 5, 4, 3, 2, 1]`

  ```javascript
  arr.sort(function (a, b) {
      return b - a;
  });
  ```

#### 以 `YYYY-MM-DD` 的方式输出今天的日期（例如 2014 年 9 月 26 日输出 2014-09-26）

```javascript
var date = new Date();
var year = date.getFullYear();
var month = date.getMonth() + 1;
var day = date.getDate();
month = month < 10 ? '0' + month : month;
day = day < 10 ? '0' + day : day;
alert(year + '-' + month + '-' + day);
```

## 2020-12-31

#### 正则表达式构造函数 `new RegExp()` 与正则表达字面量 `var reg = /.../` 有什么不同？匹配邮箱的正则表达式是？

- 区别

  - 构造函数中的正则表达式是字符串，也可以使用变量：`new RegExp(匹配模式, 修饰符)`
  - 字面量则直接是正则表达式：`var reg = /匹配模式/修饰符`

- 匹配邮箱的正则表达式：`^[a-zA-Z0-9_\-]+@[a-zA-Z0-9_\-]+(\.[a-zA-Z0-9_\-]+)$`

#### 列举 DOM 常用的查找节点的方法

- 得到节点

  ```javascript
  document.getElementById()
  ```

- 得到节点集合（Collection）

  ```javascript
  document.getElementById()
  document.getElementsByClassName()
  document.getElementsByTagName()
  ```

- 得到节点列表（NodeList）

  > IE 8.0 及以上可用
  > 可用 `forEach()` 遍历

  ```javascript
  document.querySelector()
  document.querySelectorAll()
  ```

#### 简述 Vue 的生命周期

> https://segmentfault.com/a/1190000011381906

- beforeCreate
- created
- beforeMount
- mounted
- beforeUpdate
- updated
- beforeDestroy
- destroyed

## 2020-12-29

#### 事件绑定和普通事件（事件监听）有什么区别？

传统事件绑定（`.on*`）

- 如果给同一个元素绑定了两次或者以上相同类型的事件，后面的绑定会覆盖前面的绑定
- 不支持 `DOM 事件流`（事件捕获阶段 -> 目标元素阶段 -> 事件冒泡阶段）

符合 W3C 标准的事件绑定（`.addEventListener()`）

- 如果给同一个元素绑定了两次或者以上相同类型的事件，绑定的事件会依次触发
- 支持 DOM 事件流
- 事件名不需要 `on` 前缀

#### Vue 组件的数据通信方式

- 单向数据流

## 2020-12-28

#### `call` 和 `apply` 的区别是什么？

- `call(修改后的 this 指向, 函数参数1, 函数参数2, ...)`
- `apply(修改后的 this 指向, [函数参数1, 函数参数2, ...])`

#### 简述 Sass 和 Less，以及区别

简述

- 动态样式语言

区别

- 实现方式

  - Less 基于 JavaScript，可以在客户端或服务端处理。
  - Sass 基于 Ruby，需要在服务器端处理。

- 变量

  - Less - `@` 前缀
  - Sass - `$` 前缀

#### JavaScript 原型、原型链是什么，有什么特点？

- 原型对象也是普通的对象，是对象自带的隐式 `__proto__` 属性。
- 原型也有可能有自己的原型，如果一个原型对象的原型不为 `null`，就称之为原型链。
- 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。
- 当需要一个属性时，Javascript 会先看当前对象中是否有这个属性，如果没有，就会查找其 `Prototype` 对象是否有这个属性。

## 2020-12-25

#### 如何获取对象 obj 拥有的所有属性（可枚举的、不可枚举的，不包括继承来的属性）

- 获取对象可遍历和不可遍历的属性（键名）

  ```javascript
  Object.getOwnPropertyNames(a)
  ```

- 使用 `for...in` 并过滤继承的属性

  ```javascript
  var arr = [];
  for (prop in obj) {
      if(obj.hasOwnproperty(prop)) {
          arr.push(prop);
      }
  }
  ```

## 2020-12-24

#### JavaScript 的 this、作用域

- this（指向调用者，会随着执行环境的改变而改变）
  - 在方法中，`this` 表示该方法所属的对象。
  - 如果单独使用，`this` 表示全局对象。
  - 在函数中，`this` 表示全局对象。
  - 在函数中，在严格模式下，`this` 是未定义的（`undefined`）。
  - 在事件中，`this` 表示接收事件的元素。
  - 类似 `call()` 和 `apply()` 方法可以将 `this` 引用到任何对象。

- 作用域（可访问的变量的集合）
  - 变量在函数内声明，为局部变量（只能在函数内部访问）
  - 变量在函数外定义，为全局变量（网页中所有脚本和函数均可使用） 
  - `let`、`const` 声明的变量在块级作用域（`{ ... }`）中有效

#### 闭包是什么？有什么特性？对页面有什么影响？

- 闭包就是能够读取其他函数内部变量的函数。
- 内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。
- 特性
  - 让外部访问函数内部变量成为可能。
  - 局部变量会常驻在内存中。
  - 可以避免使用全局变量，防止全局变量污染。
- 影响
  - 可能会造成内存泄漏（有一块内存空间被长期占用，而不被释放）。

#### Vue 如何更新数组数据、对象数据？

- `data` 对象中的数据通过绑定 `getter` 和 `setter` 观察数据变化并同步更新到页面中。

- 手动更新数组数据并同步到页面中：
  - 使用被 Vue 包裹过的方法
  - 直接替换整个数组（可使用 `展开` 保留原有数据）
  - 使用 Vue 对象或 Vue 的静态 `set`、`delete` 方法
    - `vm.$set(vm.数组, 下标，值)`
    - `vm.$delete(vm.数组, 下标)`
    - `Vue.set(vm.数组, 下标, 值)`
    - `Vue.delete(vm.数组, 下标)`

- 手动更新对象数据并同步到页面中：
  - 直接替换整个对象（可使用 `展开` 保留原有数据）
  - 使用 Vue 对象或 Vue 的静态 `set`、`delete` 方法
    - `vm.$set(vm.对象, 属性名，属性值)`
    - `vm.$delete(vm.对象, 属性名)`
    - `Vue.set(vm.对象, 属性名, 属性值)`
    - `Vue.delete(vm.对象, 属性名)`

## 2020-12-21

#### cookies、sessionStorage 和 localStorage 的区别

特性          | cookie                                    | sessionStorage                                | localStorage
----          | ------                                    | --------------                                | ------------
数据生命周期  | 生成时指定 maxAge（默认关闭浏览器时失效） | 页面会话期间可用                              | 一直存在，直到被清除
存放数据大小  | 4KB 左右                                  | {{colspan=2}}>= 5MB                           | {{REMOVE}}
与服务器通信  | 每次 HTTP 请求时都会在 HTTP 请求头中携带  | {{colspan=2}}需要时使用，不参与和服务器的通信 | {{REMOVE}}
易用性        | 需要自己封装方法（setCookie、getCookie）  | {{colspan=2}}可以使用原生接口，也可以封装     | {{REMOVE}}
共同点        | {{colspan=3}}保存在客户端（浏览器）       | {{REMOVE}}                                    | {{REMOVE}}

#### 同步和异步的区别？JavaScript 实现异步的方式有哪些？

- 方式
  - 回调函数
  - 事件监听
  - 发布 / 订阅模式
  - Promise
  - Generator (ES6)
  - async / await (ES7)

## 2020-12-17

#### `instanceof` 和 `typeof` 怎么用？有什么区别？

> [MDN - instanceof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)
> [MDN - typeof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof)

- instanceof 用法：`object instanceof constructor`

  > `object` 某个实例对象
  > `constructor` 某个构造函数

- typeof 用法：`typeof operand` / `typeof(operand)`

  > `operand` 一个表示对象或原始值的表达式（操作数），其类型将被返回。

- `instanceof` 运算符用来检测构造函数的 `prototype` 属性（`constructor.prototype`）是否存在于某个实例对象的原型链上。
- `typeof` 操作符返回一个字符串，表示未经计算的操作数的类型。

#### ES6 箭头函数与普通函数的区别

- 外形不同（箭头函数使用箭头定义）
- 箭头函数全都是匿名函数
- 箭头函数不具有 `arguments` 对象
- 箭头函数没有自己的 `this`（捕获其所在的上下文的 `this`，作为自己的 `this`）
- 箭头函数不具有 `prototype` 原型对象
- 箭头函数不能用于构造函数（不能 `new`）

## 2020-12-16

#### 编写一个数组去重的方法

```javascript
function arrRD(arr) {
    var arrNew = [];

    arr.forEach(function (item) {
        if (arrNew.indexOf(item) === -1) {
            arrNew.push(item);
        }
    });

    return arrNew;
}
```

#### 边输入边获取 input 输入框的值，用哪个事件比较好？

- `input`
- `keyup`

## 2020-12-15

#### 什么是严格模式？

> https://www.runoob.com/js/js-strict.html

- JavaScript 严格模式（strict mode）即 `代码在严格的条件下执行`
- 限制
  - 不允许使用未声明的变量
  - 不允许删除变量、对象、函数
  - 不允许变量重名
  - 不允许使用八进制
  - 不允许使用转义字符
  - 不允许对只读属性赋值
  - 不允许对一个使用 `getter` 方法读取的属性进行赋值
  - 不允许删除一个不允许删除的属性
  - 变量名不能使用 `arguments`、`eval` 字符串
  - 不允许使用这种语句：`with (Math) { x = cos(2) };`
  - `this` 关键字不能指向全局对象（变为 `undefined`）
    （在使用构造函数时，如果不使用 `new`，`this` 不再指向全局对象）
  - 在作用域 `eval()` 中创建的变量不能被调用
  - 新增保留关键字
    - `implements`
    - `interface`
    - `let`
    - `package`
    - `private`
    - `protected`
    - `public`
    - `static`
    - `yield`

#### 严格模式的好处？

- 消除代码运行的一些不安全之处，保证代码运行的安全。
- 提高编译器的效率，增加运行速度。
- 为未来新版本的 JavasSript 做好铺垫。

## 2020-12-11

#### Less、Sass 是什么？大家为什么要使用它们？

- 它们是 CSS 的预处理器，是 CSS 上的一种抽象层，是一种特殊的语法 / 语言，可编译为 CSS。
- 它们给 CSS 赋予了动态语言的特性（变量、继承、运算、函数、...）。
- Less 既可以在客户端上运行（借助 JavaScript，支持 IE 6+、Webkit、Firefox），
  也可以在服务端运行（借助 Node.js）。

- 优点
  - 结构清晰，便于扩展
  - 方便地屏蔽浏览器私有语法差异
  - 轻松实现多重继承
  - 完全兼容 CSS 代码，可以方便地应用到老项目中

    > Less 只是在 CSS 的语法上做了扩展，所以老的 CSS 代码也可以与 Less 代码一同编译。

#### 关于事件，IE 与 FireFox 的事件机制有什么区别？

- IE
  - 在 IE 中，事件对象是作为一个 `全局变量` 来保存和维护的。
  - 所有的浏览器事件，不管是用户触发的，还是其他事件，都会更新 `window.event` 对象。
  - 所以在代码中，只要通过 `window.event` 就可以获取事件对象，
    通过 `window.event.srcElement` 可以取得触发事件的元素，进行进一步的处理。
- FireFox
  - 在 FireFox 中，事件对象不是全局对象。
  - 一般情况下，是现场发生，现场使用。
  - FireFox 自动把事件对象作为 `参数` 传给事件处理程序。

## 2020-12-10

#### 将数字 `12345678` 转化成 RMB 形式（`12,345,678`）

```javascript
var str = '12345678';
var strArr = str.split('').reverse();

str = '';
strArr.forEach(function (value, index) {
    str += value;

    if ((index + 1) % 3 === 0) {
        str += ',';
    }
});
str = str.split('').reverse('').join('');
```

## 2020-12-08

#### 同步和异步的区别

- 同步：阻塞的
- 异步：非阻塞的
- 在同步任务完成后再进行异步任务

## 2020-12-04

#### 去除数组中重复的元素

> `['c', 'a', 'z', 'a', 'x', 'a', 'x', 'c', 'b']`

```javascript
var arr = ['c', 'a', 'z', 'a', 'x', 'a', 'x', 'c', 'b'];
var arrNew = [];

arr.forEach(function (value) {
    if (arrNew.indexOf(value) == -1) {
        arrNew.push(value);
    }
});

console.log(arrNew); // ['c', 'a', 'z', 'x', 'b']
```

## 2020-12-03

#### JavaScript 中，IE 和标准下有哪些兼容性的写法

```javascript
// 获取页面可视区的宽度
var visibleWidth = document.documentElement.clientWidth || document.body.clientWidth;

// 获取事件对象
var ev = ev || window.event;

// 获取触发事件的事件源
var target = ev.target || window.event.srcElement;

// 获取按键
var code = ev.which || ev.keyCode;

// 阻止事件冒泡
ev.stopPropagation ? ev.stopPropagation() : ev.cancelBubble = true;

// 阻止默认事件
ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;
```

#### 获取某个 DOM 对象的非行内样式的函数

```javascript
function getStyle(elem, attr) {
    return elem.currentStyle ? elem.currentStyle[attr] : window.getComputedStyle(elem, null)[attr];
}
getStyle(box, 'width');
```

#### 将 `12345678` 变成 `87654321`（反转字符串）

```javascript
var str = '12345678';
str = str.split('').reverse().join('');
```

## 2020-12-02

#### DOM 操作中，查找节点的方法

- `getElementById()`
- `getElementsByName()`
- `getElementsByClassName()`
- `getElementsByTagName()`
- `querySelector()`
- `querySelectorAll()`

#### 数组方法 `pop()`、`push()`、`shift()`、`unshift()` 的作用

方法                     | 作用
----                     | ----
`Array.pop()`            | 删除并返回数组的最后一个元素
`Array.push()`           | 向数组的末尾添加元素，并返回添加后的数组长度
`Array.shift()`          | 删除并返回数组的第一个元素
`Array.unshift()`        | 向数组的头部插入元素，并返回插入后的数组长度

#### 判断字符串 `asdfssaaasasasasaa` 中出现次数最多的字符以及出现的次数

```javascript
var str = 'asdfssaaasasasasaa';
var count = {};
var maxCount = 0;
var maxChar = '';

str.split('').forEach(function (char) {
    count[char] == undefined ? count[char] = 1 : count[char] += 1;
});

for (var char in count) {
    if (count[char] > maxCount) {
        maxCount = count[char];
        maxChar = char;
    }
}

alert('出现次数最多的是“' + maxChar + '”，出现了 ' + maxCount + ' 次');
```

## 2020-12-01

#### 获取到页面中所有的 `checkbox` 标签，并把这些 DOM 对象放进数组中

```javascript
var checkboxList = document.querySelectorAll('input[type="checkbox"]');
var checkboxArr = [];
var pos = checkboxList.length;
while (pos--) {
    checkboxArr.push(checkboxList[pos]);
}
```

#### 什么时候会出现 `undefined` 值

- 定义了变量但未初始化（赋值）
- 定义了一个值是 `undefined` 的变量
- 获取对象不存在的属性值
- 获取数组不存在的元素
- 定义一个函数，有形参，但在调用时没有传递实参
- 输出没有返回值的函数的调用结果

## 2020-11-27

#### 对 JSON 的了解

- 轻量级数据交互格式
- 可以形成复杂的嵌套格式
- 解析非常方便

#### `document.write` 和 `innerHTML` 的区别

- `document.write` 重写整个 `document`，写入字符串类型的 HTML 内容。
- `innerHTML` 是 `HTMLElement` 的属性，是一个元素的内部 HTML 内容。

## 2020-11-26

#### CSS 的 `content` 属性的作用和应用

- 作用：应用在伪元素 `::before` / `::after` 上，用于插入生成内容。
- 应用

  - 清除浮动

    ```css
    .clearfix::after {
        content: "";
        display: block;
        clear: both;
    }
    ```

  - [计数器](https://www.runoob.com/css/css-counters.html)
    - CSS 计数器根据规则来递增变量
    - 配合伪元素 `::before` / `::after` 实现
    - CSS 计数器使用到以下几个属性
      - `counter-reset` - 创建或者重置计数器
      - `counter-increment` - 递增变量
      - `content` - 插入生成的内容
      - `counter()` 或 `counters()` 函数 - 将计数器的值添加到元素
    - 要使用 CSS 计数器，得先用 `counter-reset` 创建

#### 减少页面加载时间的方法

- 使用压缩的 CSS、JavaScript 文件。
- 合并 CSS、JavaScript 文件，减少 HTTP 请求。
- 使用精灵图，减少 HTTP 请求。
- 延时加载图片（Lazy Load）。
- 外部引入的 CSS、JavaScript 文件放在末尾。
- 减少 DOM 操作，尽可能用变量替代不必要的 DOM 操作。

#### `new` 操作符具体做了什么？

1. 在构造函数中创建一个 `空对象`
2. 把构造函数中的 `this` 指向这个 `空对象`
3. 执行构造函数中的代码，给这个 `空对象` 初始化 `属性和方法`（继承构造函数的原型）
4. 返回这个对象（因此使用 new 关键字后，不需要在构造函数中 return 这个对象）

## 2020-11-25

#### CSS3 的新特性

> [CSS3](https://www.runoob.com/css3/css3-tutorial.html)

- 更多的选择器
- 伪类（:first-of-type、:last-of-type、...）
- 伪元素（::selection）
- 媒体查询
- 弹性盒子
- 多列
- 变形（transform）
- 边框图片（border-image）
- 动画
- 多背景
- 渐变（linear-gradient、radial-gradient、repeating-linear-gradient、repeating-radial-gradient）
- 颜色（RGBA、HSLA）
- 阴影（box-shadow、text-shadow）
- 圆角（border-radius）
- ...

#### 新的 HTML5 文档类型和字符集

- HTML5 文档类型：html（`<!DOCTYPE html>`）
- HTML5 字符集：UTF-8（`<meta charset="UTF-8">`）

#### CSS3 新增伪类

- `:first-of-type`
- `:last-of-type`
- `:only-of-type`
- `:only-child`
- `:nth-child(n)`
- `:enabled`、`:disabled`、`:checked`

## 2020-11-24

#### `px` 和 `em` 的区别

- `px` 的值是固定的，指定是多少就是多少.
- `em` 的值不是固定的，`1em` 为当前元素的字体大小。
  （若当前元素未设置字体大小，则继承父元素的字体大小）
- 浏览器的默认字体大小为 `16px`（默认情况下 `1em = 16px`）

#### `foo = foo || bar`，这行代码是什么意思？为什么要这样写？

- 相当于：`if (!foo) { foo = bar }`

  - 如果 `foo` 的值存在或值为真，值不变，否则把 `bar` 的值赋给 `foo`。

- 短路表达式

  - 作为 `&&` 和 `||` 操作符的操作数表达式
  - 在进行求值时，只要最终的结果已经可以确定是真或假，求值过程就终止
  - 这称为 `短路求值`

## 2020-11-20

#### GET 和 POST 的区别？何时使用 POST？

- GET 请求
  - 一般用于信息获取
  - 使用 URL 传递参数
  - 对所发送的数据量有限制，一般在 2000 字节内（部分浏览器是 8000 字节）

- POST 请求
  - 一般用于修改服务器上的资源
  - 对所发送的数据量没有限制

- 在以下情况中，需要使用 POST 请求
  - 无法使用缓存文件（更新服务器上的文件或数据库）
  - 向服务器发送大量数据（POST 没有数据量限制）
  - 发送包含未知字符的用户输入时（POST 比 GET 更稳定、更可靠）

## 2020-11-19

#### JSONP 的原理？为什么 JSONP 不是真正的 AJAX？

- 原理：动态创建 `script` 标签，回调函数
- 原因：AJAX 是页面无刷新请求数据操作

#### AJAX 是什么？如何创建一个 AJAX？

- AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。
- AJAX 不是新的编程语言，而是一种使用现有标准的新方法。
- AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。
- AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。
- 实现步骤

  ```javascript
  // 创建 AJAX 对象
  var xhr = null;
  if (window.XMLHttpRequest) {
      xhr = new XMLHttpRequest();
  } else {
      xhr = new ActiveXObject('Microsoft.XMLHTTP');
  }

  // 设置 AJAX 请求方式以及请求地址
  xhr.open(请求方式, 请求地址);

  // 设置请求头
  xhr.setRequestHeader(属性名, 属性值);

  // 设置监听事件，获取服务器端传给客户端的响应数据
  xhr.onreadystatechange = function () {
      if (xhr.readyState == 4 && xhr.status == 200) {
          console.log(xhr.responseText);
      }
  }

  // 发送请求（请求方式为 POST 时需要参数）
  xhr.send();
  ```

#### 简述 AJAX 的过程?

1) 创建 XMLHttpRequest 对象（创建一个异步调用对象）
2) 创建一个新的 HTTP 请求，并指定该 HTTP 请求的请求方式、URL 和验证信息
3) 设置响应 HTTP 请求状态变化的函数
4) 发送 HTTP 请求
5) 获取异步调用返回的数据
6) 使用 JavaScript 和 DOM 实现局部刷新

## 2020-11-18

#### 用 JavaScript 实现随机选取 10-100 之间的 10 个数字，存入一个数组，并排序

```javascript
var arr = [];
for (var i = 0; i < 10; i++) {
    var num = Math.floor(Math.random() * 91 + 10);
    arr.push(num);
}
arr.sort(function (a, b) {
    return a - b
});
```

#### 把两个数组合并，并删除第二个元素

```javascript
var arr1 = ['a', 'b', 'c'];
var arr2 = ['d', 'e', 'f'];
var arr3 = arr1.concat(arr2);
arr3.splice(1, 1);
```

#### 以下代码的执行结果

```javascript
var a = 10;
b = 20;
c = 4;
var res = ++b + c + a++;
console.log(res);
```

- `21 + 4 + 10`
- `35`

## 2020-11-17

#### 将字符串 `<tr><td>{$id}</td><td>{$name}</td></tr>` 中的 `{$id}` 替换为 `10`，`{$name}` 替换为 `Tony`

```javascript
var str = '<tr><td>{$id}</td><td>{$name}</td></tr>';
str = str.replace(/\{\$id\}/g, '10').replace(/\{\$name\}/g, 'Tony');
```

#### 下列代码会输出什么？为什么？

```javascript
var foo = 1;
(function () {
    console.log(foo);
    var foo = 2;
    console.log(foo);
})();
```

- `undefined`、`2`
- 函数声明、变量声明会提升
- 变量声明只提升变量名

## 2020-11-13

#### `call` 和 `apply` 的异同

**相同**

- 改变 this 的指向（修改方法的执行环境）

**不同**

- `call(修改后的 this 指向, 函数参数1, 函数参数2, ...)`
- `apply(修改后的 this 指向, [函数参数1, 函数参数2, ...])`

## 2020-11-12

#### JavaScript 的 `typeof` 返回哪些数据类型

- `number`、`string`、`boolean`、`function`、`object`、`undefined`、`symbol`

#### 例举 3 种强制类型转换和 2 种隐式类型转换

- 强制类型转换：`parseInt()`、`parseFloat()`、`Number()`、`toString()`
- 隐式类型转换：`1 == '1'`（true）、`0 == false`（true）、`null == undefined`（true）

#### `split()` 和 `join()` 的区别

- `split()` 分割字符串
- `join()` 将数组拼接为字符串

## 2020-11-11

#### 原生 JavaScript 的 `window.onload` 与 jQuery 的 `$(document).ready(function () { })` 有什么不同？

- `window.onload`
  在所有资源文件加载完毕后执行
- `$(document).ready(function () { })`
  在文档结构准备好后执行

#### `img` 的 `alt` 与 `title` 的异同？`strong` 与 `em` 的异同?

- `alt` (alttext)
  - 为不能显示图像、窗体或 applets 的用户代理（UA）指定替换文字
  - 替换文字的语言由 `lang` 属性指定
  - 在IE浏览器下会在没有 title 时把 alt 当成 tooltip 显示
- `title` (tooltip)
  - 为设置该属性的元素提供建议性的信息
  - 鼠标悬浮在元素上方时显示
- `strong`
  - 粗体强调标签，普通强调，表示内容的重要性。
- `em`
  - 斜体强调标签，更强烈的强调，表示内容的强调点。

#### 网页制作会用到的图片格式

- `PNG`（PNG-8、PNG-24）、`JPEG`、`GIF`、`SVG`、`WebP`
- 在质量相同的情况下，WebP 格式的图像的体积要比 JPEG 格式图像小 40%

## 2020-11-10

#### 使用 `link` 和 `@import` 引入 CSS 的区别？

- `link` 属于 `HTML 标签`，而 `@import` 是由 `CSS` 提供的。
- `@import` 只在 `IE5` 以上可以被识别，而 `link` 不存在浏览器兼容性问题（link 属于 HTML 标签）。
- 页面加载时，`link` 引入的 CSS 会 `同时` 被加载，而 `@import` 引入的 CSS 会在页面 `加载完成后` 才会被加载。
- CSS 权重：`link` > `@import`（@import 是将引入的样式导入到当前的页面中）

#### 为什么要 `初始化` 样式？

- 由于浏览器兼容问题，在不同的浏览器下，标签的 `默认样式` 不同，若不初始化会导致不同浏览器之间产生 `显示差异`。
- 初始化 CSS 对 `搜索引擎优化` 产生小 `影响`。

#### `BFC` 是什么？

> [格式化上下文简介](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout/Intro_to_formatting_contexts)

- 块级元素布局规范。
- BFC（块级格式化上下文）是指在浏览器中创建的一个 `独立的渲染区域`，
  该区域内所有元素的布局 `不会影响到区域外` 元素的布局，这个渲染区域只对 `块级元素` 起作用。
- 一个创建了新的 BFC 的盒子是独立布局的，盒子内的元素的布局不会影响盒子外面的元素。
- 在同一个 BFC 中的两个相邻的盒子会在垂直方向产生 `外边距（margin）重叠` 问题。

## 2020-11-08

#### 下列 JavaScript 代码执行后，依次 alert() 的结果是？

```javascript
(function test() {
    var a = b = 5;
    alert(typeof a);
    alert(typeof b);
})();
alert(typeof a);
alert(typeof b);
```

- `number` -> `number` -> `undefined` -> `number`

#### 下列 JavaScript 代码的输出结果为？

```javascript
function foo(a) {
    alert(arguments.length);
}
foo(1, 2, 3);
```

- `3`
- 实参的长度（数量）

#### 行内元素（内联元素）和块级元素的具体区别是什么？行内元素的 padding 和 margin 可设置吗？

- 行内元素（inline）特性
  - 和相邻的行内元素在同一行
  - 不可设置：`width`、`height`、`padding-top`、`padding-bottom`、`margin-top`、`margin-bottom`
  - 可设置：`padding-left`、`padding-right`、`margin-left`、`margin-right`

- 块级元素（block）特性
  - 总是独占一行，表现为另起一行开始，且其后的元素也必须另起一行显示。
  - 可设置：`width`、`height`、`padding`、`margin`

- 浏览器默认的 inline-block 元素（拥有内在尺寸，可设置高宽，但不会自动换行）
  - `<input>`、`<img>`、`<button>`、`<texterea>`、`<label>`

## 2020-11-06

#### 有哪几种方式可以直接获取这个 div 的 `DOM 对象` ？如何把 `DOM 对象` 转换为 `jQuery 对象` ？

> `<div class='aabbcc' id='nodesView'></div>`

- `document.getElementById('nodesView')`
- `document.getElementsByClassName('aabbcc')[0]`
- `document.querySelector('#nodesView')`
- `document.querySelector('.aabbcc')`
- 转换为 jQuery 对象：`$(DOM 对象)`

#### 原生的 JavaScript 如何显示或隐藏一个 DOM 元素？

- `DOM.style.display = 'block'`
- `DOM.style.display = 'none'`
- `DOM.style.visibility = 'visible'`
- `DOM.style.visibility = 'hidden'`

#### JavaScript 的循环语句有哪些？

- `for (...; ...; ...) { }`
- `for (... in ...) { }`
- `while ( ) { }`
- `do { } while ( )`

## 2020-11-05

#### `console.log(8 | 1)` 的输出值

- 输出值：9

十进制 | 二进制
:----: | :----:
8      | 1000
1      | 0001
-----  | -----
9      | 1001

> [JavaScript 位运算符](https://www.w3school.com.cn/js/js_bitwise.asp)

运算符 | 名称 | 描述
:----: | :--: | ----
`&`    | AND  | 如果两位都是 1，则设置每位为 1
`|`    | OR   | 如果两位之一为 1，则设置每位为 1
`^`    | XOR  | 如果两位只有一位为 1，则设置每位为 1
`~`    | NOT  | 反转所有位

#### `alert(0.4 * 0.2)` 的结果是多少？和你预期的一样吗？如果不一样怎么解决？

- 结果：0.08000000000000002
- 有误差，比准确结果偏大。
- 解决方法
  - 将小数转为整数来处理
  - [bignumber.js](https://github.com/MikeMcl/bignumber.js)
  - [decimal.js](https://github.com/MikeMcl/decimal.js)
  - [big.js](https://github.com/MikeMcl/big.js)

## 2020-11-04

#### 如何判断一个 JavaScript 变量是数组类型

```javascript
var arr = [1, 2, 3, 4, 5];
Array.isArray(arr);                  // true
arr instanceof Array;                // true
Object.prototype.toString.call(arr); // "[object Array]"
```

## 2020-11-03

#### 简述 `readonly` 与 `disabled` 的区别

- `readonly` 只对 `input`（text / password）和 `textarea` 有效，`disabled` 对于所有的表单元素都有效。
- 表单元素设置 `disabled` 属性后，将表单以 `POST` 或 `GET` 的方式提交，该元素的值不会被传递出去，而 `readonly` 会将该值传递出去。

## 2020-11-01

#### 阻止事件冒泡和默认事件的方法

```javascript
// 阻止事件冒泡
ev.stopPropagation ? ev.stopPropagation() : ev.cancelBubble = true;

// 阻止默认事件
ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;
```

> 原生 JavaScript：`return false` 只阻止默认行为，不阻止事件冒泡。
> jQuery：`return false` 既阻止默认行为，也阻止事件冒泡。

#### 添加节点、删除节点、替换节点、插入到某个节点的方法

- `DOM节点.appendChild()`
- `DOM节点.removeChild()`
- `DOM节点.replaceChild()`
- `DOM节点.insertBefore()`、`DOM节点.insertAfter()`

## 2020-10-30

#### CSS 中 `rgba()` 与 `opacity` 的透明效果的区别

- `rgba()` 作用于对应的属性（子元素不会继承透明效果），`opacity` 作用于当前元素。

#### JavaScript 事件委托

- 符合 W3C 标准的事件绑定 `addEventLisntener` / `attachEvent`
- 不把事件要绑定到 `子元素`，而是绑定到该元素的 `父元素（或祖先元素）` 上，利用 `事件冒泡` 原理，触发执行效果。

## 2020-10-29

#### CSS 的基本语句构成

```text
一个或多个选择器 {
    属性名: 属性值;
    属性名: 属性值;
}
```

#### 如何让一个 DOM 节点在被点击时候执行一个函数？

- 在元素中添加 `onclick` 属性（静态绑定）
- 在 JavaScript 中（动态绑定）

  ```javascript
  DOM节点.onclick = function () {
      执行的代码
  };
  ```

- 在 JavaScript 中（动态绑定）

  ```javascript
  DOM节点.addEventListener('click', function () {
      执行的代码
  }, [useCapture]);
  ```

#### 简述定义函数的几种方式

> 匿名函数不能单独存在，需要赋值给一个变量、一个事件。
> 若匿名函数单独存在，需要 `立即执行函数表达式`（IIFE）。

- 函数声明

  > 有名函数

  ```javascript
  function 函数名( [形参列表] ) {
      函数体
      [ return 返回值; ]
  }
  ```

- 函数表达式

  > 匿名函数
  > 存储在变量中
  > 通过变量名调用

  ```javascript
  var 变量名 = function ( [形参列表] ) {
      函数体
      [ return 返回值; ]
  };
  ```

- 立即调用（IIFE）

  > 匿名函数

  ```javascript
  ;(function () {
      函数体
  })();

  ;(function () {
      函数体
  }());
  ```

- Function() 构造函数

  ```javascript
  var 变量名 = new Function('形参1', '形参2', ..., '函数体');
  ```

## 2020-10-24

#### 简述浏览器渲染页面机制

1. 解析 HTML 生成 `DOM 树`
2. 解析 CSS 生成 `CSSOM 规则树`
3. 将 `DOM 树` 与 `CSSOM 规则树` 合并在一起生成 `渲染树`
4. 遍历 `渲染树` 开始布局，计算每个节点的位置大小信息
5. 将 `渲染树` 每个节点绘制到屏幕

#### 简述一个完整的 HTTP 事务处理过程

1. 域名解析
2. 发起 TCP 的 3 次握手
3. 建立 TCP 连接后发起 HTTP 请求
4. 服务器响应 HTTP 请求，浏览器得到 HTML 代码
5. 浏览器解析 HTML 代码，并请求 HTML 代码中的资源
6. 浏览器对页面进行渲染

#### 前端性能优化有哪些？

- 减少请求资源的大小或次数
  - 尽量使用合并和压缩后的 CSS、JavaScript 文件
  - 使用图标时，尽量所使用字体或 SVG 图片代替传统 PNG 图片。
  - 图片尽量采用懒加载（延迟加载）
  - 使用图片精灵，将多张图片合并为一张图片。
- 能用 CSS 实现的效果，尽量使用 CSS 实现。
- 避免引入大量第三方库却只是用到里面的一个小功能
- 避免使用 iframe
- 减少 cookie 的使用
- 前端与后端进行数据交互时，尽可能基于 JSON 格式进行数据传输。
- 前端与后端协商，合理使用 keep-alive（持久连接）。

## 2020-10-23

#### `var` 和 `const` 的区别

- `var` 定义的变量可以修改，可以不初始化（未初始化时为 `undefined`）。
- `const` 定义的变量不可以修改，而且必须初始化。

#### 在 CSS 布局中，什么场景下会出现外边距合并问题？如何解决？

> https://www.w3school.com.cn/css/css_margin_collapsing.asp

- 当两个垂直外边距相遇时，它们会合并为一个外边距，合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。
- `兄弟级` 无法解决，`父子级` 可解决：
  - 给父级添加 `border`
  - 给父级添加 `padding`
  - 给父级添加 `overflow: hidden`
  - 给子级或父级添加 `float: left`
  - 给子级或父级添加 `position: absolute`
  - 给子级或父级添加 `display: inline-block`

#### `break`、`continue`、`return`、`throw` 的作用

- `break`：跳出循环（结束）
- `continue`：跳出本次循环，进入下次循环
- `return`：在函数中使用，指定返回值，中止当前函数的执行。
- `throw`：中止程序，抛出异常。

#### `XSS` 攻击原理与防御

- 原理
  攻击者向有 XSS 漏洞的网站中输入（传入）恶意的 HTML、JavaScript 代码，当其它用户浏览该网站时，这段代码会自动执行，从而达到攻击的目的（盗取用户 Cookie、破坏页面结构、重定向到其它网站等）。

- 防御
  校验用户输入的内容，对用户输入的内容进行处理，去除恶意内容。

## 2020-10-22

#### 在 CSS 布局中，什么场景下出现元素高度塌陷，如何解决元素高度塌陷问题？

- 元素浮动时脱离文档流，导致不占据页面空间，会对父元素的高度造成一定的影响。
- 解决元素高度塌陷问题
  - 给父元素设置高度
  - 将父元素的 `overflow` 属性设置为 `hidden` 或 `auto`
  - 使用 `伪元素` 清除浮动

    ```css
    .clearfix::after {
        content: "";
        display: block;
        clear: both;
    }
    ```

#### `display: none` 和 `visibility: hidden` 的区别？

- `display: none` 隐藏后的元素不占据任何空间（文档流）
- `visibility: hidden` 隐藏后的元素仍然占据空间（文档流）
- `visibility` 具有继承性：
  给父元素设置 `visibility: hidden`，子元素也会继承这个属性。
  如果同时给子元素设置 `visibility: visible`，则子元素会显示出来。
- `visibility: hidden` 不会影响计数器的计数（例如 `<ol><li></li></ol>`）。

#### CSS 定位有几种，各个定位方式有什么区别？

- `static`（静态定位）、`relative`（相对定位）、`fixed`（固定定位）、`absolute`（绝对定位）、`sticky`（粘性定位）
- `static` 定位：
  HTML 元素的默认值，遵循正常的文档流对象。
  静态定位的元素不会受到 `top`、`bottom`、`left`、`right` 属性影响。
- `fixed` 定位：
  元素的位置相对于浏览器窗口固定，即使滚动页面它也不会移动。
- `relative` 定位：
  相对元素自身原位置进行定位。
- `absolute` 定位：
  相对于最近的已定位父元素进行定位
  如果没有已定位的父元素，就相对于根元素 `<html>` 进行定位
- `sticky` 定位：
  基于滚动位置进行定位
  在跨越特定阈值（`top`、`right`、`bottom`、`left`）前为相对定位，之后为固定定位。

#### JavaScript 原始数据类型有哪些？引用类型数据有哪些？原始数据类型和引用类型的区别?

- 原始数据类型（栈）：`Undefined`、`Null`、`Boolean`、`Number`、`String`
- 引用数据类型（堆）：对象（数组、函数等）
- 区别
  - 存储位置：`原始数据类型` 是存储在 `栈` 中的简单数据段，`引用数据类型` 是存储在 `堆` 中的对象。
  - 传值方式：基本数据类型是 `按值传递`（修改后不会影响原始值），引用类型是 `引用传递`（修改后会影响原始值）。

## 2020-10-20

#### 对 `盒子模型` 这个概念的理解以及它涉及到的 CSS 属性

- 涉及属性：边界（margin）、边框（border）、填充（padding）、内容（content）
- 这些属性我们可以用日常生活中的常见事物 —— 盒子作一个比喻来理解，所以叫它盒子模型。
- CSS 盒子模型就是在网页设计中经常用到的 CSS 技术所使用的一种思维模型。

#### 前端页面有哪三层构成，分别是什么？作用是什么？

- 结构层、表示层、行为层

- 结构层：
  由 HTML 或 XHTML 之类的标记语言负责创建。
  标签对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。
  例如，P 标签表达了这样一种语义：“这是一个文本段。”

- 表示层：
  由 CSS 负责创建。 
  CSS 对“如何显示有关内容”的问题做出了回答。

- 行为层：
  负责回答“内容应该如何对事件做出反应”这一问题。
  这是 JavasSript 语言和 DOM 主宰的领域。
