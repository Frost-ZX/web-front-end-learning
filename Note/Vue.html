<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Vue&period;js&#xFF08;2&period;x&#xFF09;</title>
        <style>
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-body vscode-light">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="./assets/style.css">
<script src="./assets/script.js"></script>
<div class="contents"></div>
<h1 id="vue-js-2-x">Vue.js（2.x）</h1>
<ul>
<li><a href="#vue-js-2-x">Vue.js（2.x）</a></li>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E7%BD%91%E7%AB%99">相关网站</a></li>
<li><a href="#data-%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1">data（数据对象）</a>
<ul>
<li><a href="#%E8%AE%BF%E9%97%AE">访问</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F">注意</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95">模板语法</a>
<ul>
<li><a href="#%E6%8F%92%E5%80%BC">插值</a>
<ul>
<li><a href="#%E6%96%87%E6%9C%AC">文本</a></li>
<li><a href="#html">HTML</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%8C%87%E4%BB%A4">指令</a>
<ul>
<li><a href="#v-bind">v-bind</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B-1">简介</a></li>
<li><a href="#%E7%94%A8%E6%B3%95">用法</a></li>
</ul>
</li>
<li><a href="#v-on">v-on</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B-2">简介</a></li>
<li><a href="#%E7%94%A8%E6%B3%95-1">用法</a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6">事件修饰符</a></li>
<li><a href="#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6">按键修饰符</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E4%BF%AE%E9%A5%B0%E9%94%AE">系统修饰键</a></li>
</ul>
</li>
<li><a href="#v-if-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93">v-if（条件渲染）</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B-3">简介</a></li>
<li><a href="#%E7%94%A8%E6%B3%95-2">用法</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F-1">注意</a></li>
</ul>
</li>
<li><a href="#v-show-%E6%9D%A1%E4%BB%B6%E6%98%BE%E7%A4%BA">v-show（条件显示）</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B-4">简介</a></li>
<li><a href="#%E7%94%A8%E6%B3%95-3">用法</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F-2">注意</a></li>
</ul>
</li>
<li><a href="#v-for-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93">v-for（列表渲染）</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B-5">简介</a></li>
<li><a href="#%E7%94%A8%E6%B3%95-4">用法</a></li>
<li><a href="#%E7%BB%B4%E6%8A%A4%E7%8A%B6%E6%80%81">维护状态</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B">数组更新检测</a>
<ul>
<li><a href="#%E5%8F%98%E6%9B%B4%E6%96%B9%E6%B3%95">变更方法</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#v-model-%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A">v-model（表单输入绑定）</a>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95">基础用法</a></li>
<li><a href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6">修饰符</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95">事件处理方法</a>
<ul>
<li><a href="#%E7%94%A8%E6%B3%95-5">用法</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F-3">注意</a></li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7">计算属性</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B-6">简介</a></li>
<li><a href="#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95-1">基础用法</a></li>
<li><a href="#setter">setter</a></li>
</ul>
</li>
<li><a href="#%E4%BE%A6%E5%90%AC%E5%99%A8">侦听器</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B-7">简介</a></li>
<li><a href="#%E7%94%A8%E6%B3%95-6">用法</a></li>
</ul>
</li>
<li><a href="#%E7%BB%84%E4%BB%B6">组件</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B-8">简介</a></li>
<li><a href="#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95-2">基础用法</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8">使用</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F-4">注意</a></li>
</ul>
</li>
<li><a href="#data">data</a></li>
<li><a href="#%E9%80%9A%E8%BF%87-prop-%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE">通过 Prop 向子组件传递数据</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B-9">简介</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">使用方式</a></li>
<li><a href="#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81">单向数据流</a></li>
<li><a href="#prop-%E9%AA%8C%E8%AF%81">Prop 验证</a></li>
</ul>
</li>
<li><a href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0-%E7%BB%84%E4%BB%B6">访问元素 &amp; 组件</a>
<ul>
<li><a href="#%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E6%88%96%E5%AD%90%E5%85%83%E7%B4%A0-refs">访问子组件实例或子元素（$refs）</a></li>
<li><a href="#%E8%A7%A6%E5%8F%91%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6-emit">触发父组件的自定义事件（$emit）</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-1">使用方式</a></li>
<li><a href="#%E4%BE%8B%E5%AD%90">例子</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%8F%92%E6%A7%BD-slot">插槽（slot）</a>
<ul>
<li><a href="#%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD">默认插槽</a>
<ul>
<li><a href="#%E4%BE%8B%E5%AD%90-1">例子</a></li>
</ul>
</li>
<li><a href="#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD">具名插槽</a>
<ul>
<li><a href="#%E4%BE%8B%E5%AD%90-2">例子</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F-5">注意</a></li>
</ul>
</li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD-slot-scope">作用域插槽（slot-scope）</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6-%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6">动态组件 &amp; 异步组件</a>
<ul>
<li><a href="#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6">动态组件</a></li>
</ul>
</li>
<li><a href="#transition-%E7%BB%84%E4%BB%B6">transition 组件</a>
<ul>
<li><a href="#%E5%8D%95%E5%85%83%E7%B4%A0-%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BF%87%E6%B8%A1-transition">单元素 / 组件的过渡（transition）</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B-10">简介</a></li>
<li><a href="#%E8%BF%87%E6%B8%A1%E7%9A%84%E7%B1%BB%E5%90%8D">过渡的类名</a></li>
<li><a href="#javascript-%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0">JavaScript 钩子函数</a></li>
</ul>
</li>
<li><a href="#%E5%88%97%E8%A1%A8%E7%9A%84%E8%BF%9B%E5%85%A5-%E7%A6%BB%E5%BC%80%E8%BF%87%E6%B8%A1-transition-group">列表的进入 / 离开过渡（transition-group）</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B-11">简介</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%87%E6%BB%A4%E5%99%A8">过滤器</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8">定义过滤器</a>
<ul>
<li><a href="#%E5%B1%80%E9%83%A8">局部</a></li>
<li><a href="#%E5%85%A8%E5%B1%80">全局</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8-1">使用</a>
<ul>
<li><a href="#%E6%99%AE%E9%80%9A%E6%96%B9%E5%BC%8F">普通方式</a></li>
<li><a href="#%E4%B8%B2%E8%81%94">串联</a></li>
<li><a href="#%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0">接收参数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">生命周期</a>
<ul>
<li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></li>
<li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">生命周期钩子</a>
<ul>
<li><a href="#beforecreate">beforeCreate</a></li>
<li><a href="#created">created</a></li>
<li><a href="#beforemount">beforeMount</a></li>
<li><a href="#mounted">mounted</a></li>
<li><a href="#beforeupdate">beforeUpdate</a></li>
<li><a href="#updated">updated</a></li>
<li><a href="#beforedestroy">beforeDestroy</a></li>
<li><a href="#destroyed">destroyed</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F-6">注意</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#vue-cli-%E8%84%9A%E6%89%8B%E6%9E%B6">Vue CLI（脚手架）</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B-12">简介</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5">相关链接</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE-webpack">配置 webpack</a>
<ul>
<li><a href="#%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8">代理服务器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#vue-router-%E8%B7%AF%E7%94%B1">Vue Router（路由）</a>
<ul>
<li><a href="#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5-1">相关链接</a></li>
<li><a href="#%E5%AE%89%E8%A3%85">安装</a>
<ul>
<li><a href="#%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD-cdn">直接下载 / CDN</a></li>
<li><a href="#npm">NPM</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F-7">注意</a></li>
</ul>
</li>
<li><a href="#%E9%85%8D%E7%BD%AE">配置</a>
<ul>
<li><a href="#router-index-js">router/index.js</a>
<ul>
<li><a href="#%E4%BE%8B%E5%AD%90-3">例子</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D">动态路由匹配</a></li>
<li><a href="#%E9%87%8D%E5%AE%9A%E5%90%91-redirect-%E5%92%8C%E5%88%AB%E5%90%8D-alias">重定向（redirect）和别名（alias）</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82-props">路由组件传参（props）</a>
<ul>
<li><a href="#%E5%B8%83%E5%B0%94%E6%A8%A1%E5%BC%8F">布尔模式</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F">对象模式</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F">函数模式</a></li>
</ul>
</li>
<li><a href="#%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1-children">嵌套路由（children）</a></li>
</ul>
</li>
<li><a href="#router-link">router-link</a>
<ul>
<li><a href="#to-%E5%B1%9E%E6%80%A7">to 属性</a></li>
<li><a href="#replace-%E5%B1%9E%E6%80%A7">replace 属性</a></li>
<li><a href="#append-%E5%B1%9E%E6%80%A7">append 属性</a></li>
<li><a href="#tag-%E5%B1%9E%E6%80%A7">tag 属性</a></li>
<li><a href="#active-class-%E5%B1%9E%E6%80%A7">active-class 属性</a></li>
<li><a href="#exact-active-class-%E5%B1%9E%E6%80%A7">exact-active-class 属性</a></li>
<li><a href="#exact-%E5%B1%9E%E6%80%A7">exact 属性</a></li>
<li><a href="#event-%E5%B1%9E%E6%80%A7">event 属性</a></li>
<li><a href="#%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE">接收数据</a></li>
</ul>
</li>
<li><a href="#router-view">router-view</a></li>
</ul>
</li>
</ul>
<h1 id="简介">简介</h1>
<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。<br>
与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。<br>
Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。<br>
另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
<h1 id="相关网站">相关网站</h1>
<ul>
<li><a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></li>
<li><a href="https://www.runoob.com/vue2/vue-tutorial.html">https://www.runoob.com/vue2/vue-tutorial.html</a></li>
</ul>
<h1 id="data-数据对象">data（数据对象）</h1>
<pre><code class="language-javascript"><div><span class="hljs-keyword">new</span> Vue({
    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;...&#x27;</span>,
    <span class="hljs-attr">data</span>: {
        <span class="hljs-comment">// 数据对象</span>
        ...
    }
});
</div></code></pre>
<h3 id="访问">访问</h3>
<ul>
<li><code>实例对象.$data.属性名</code></li>
<li><code>实例对象._data.属性名</code></li>
</ul>
<h3 id="注意">注意</h3>
<ul>
<li>Vue 对 <code>data</code> 对象中的属性递归设置 <code>getter</code> &amp; <code>setter</code> 观察数据变化</li>
<li>不会观察 <code>prototype</code> 原型中的数据变化</li>
<li>不推荐把 DOM 元素设置为 <code>data</code> 对象中的属性值</li>
</ul>
<h1 id="模板语法">模板语法</h1>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/syntax.html">https://cn.vuejs.org/v2/guide/syntax.html</a></p>
</blockquote>
<h2 id="插值">插值</h2>
<h3 id="文本">文本</h3>
<ul>
<li>
<p>数据绑定最常见的形式就是使用 <code>Mustache</code> 语法 (双大括号) 的文本插值：</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Message: {{ msg }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
<blockquote>
<p>Mustache 标签将会被替代为对应 <code>数据对象</code> 上 <code>msg</code> 属性的值。</p>
<p>无论何时，绑定的数据对象上的 <code>msg</code> 属性发生了改变，插值处的内容都会更新。<br>
通过使用 <code>v-once</code> 指令，可以执行一次性插值，当数据改变时，插值处的内容不会更新。<br>
注意：这会影响到该节点上的其它数据绑定。</p>
</blockquote>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-once</span>&gt;</span>Message: {{ msg }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
</li>
<li>
<p>也可以使用 <code>v-text</code> 指令显示文本</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
</li>
</ul>
<h3 id="html">HTML</h3>
<ul>
<li>
<p><code>双大括号</code> 会将数据解析为 <code>普通文本</code>，而非 HTML 代码。</p>
</li>
<li>
<p>为了输出真正的 <code>HTML</code>，需要使用 <code>v-html</code> 指令：</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;rawHtml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
</li>
<li>
<p>注意</p>
<ul>
<li>在站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。</li>
<li>建议只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。</li>
</ul>
</li>
</ul>
<h1 id="指令">指令</h1>
<h2 id="v-bind">v-bind</h2>
<h3 id="简介-1">简介</h3>
<p><code>v-bind</code> 指令可以用于响应式地更新 <code>HTML attribute</code></p>
<h3 id="用法">用法</h3>
<ul>
<li>
<p><code>v-bind:参数=&quot;表达式&quot;</code></p>
<blockquote>
<p><code>参数</code> 为 HTML 标签属性名<br>
<code>表达式</code> 可以是 <code>data</code> 对象中的属性名，也可以是表达式（例如 <code>num * num</code>、<code>num &gt; 10</code>）</p>
</blockquote>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
</div></code></pre>
<pre><code class="language-javascript"><div><span class="hljs-keyword">new</span> Vue({
    ...
    data: {
        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;链接&#x27;</span>
    }
});
</div></code></pre>
</li>
<li>
<p>动态参数：<code>v-bind:[属性名]=&quot;表达式&quot;</code></p>
<blockquote>
<p><code>属性名</code> 为 <code>data</code> 对象中的属性名<br>
<code>属性名</code> 会被转换为小写，因此不能使用大写字母<br>
动态参数表达式有一些语法约束，某些字符（例如空格、引号）是无效的。</p>
</blockquote>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:</span>[<span class="hljs-attr">attr_name</span>]=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
</div></code></pre>
<pre><code class="language-javascript"><div><span class="hljs-keyword">new</span> Vue({
    ...
    data: {
        <span class="hljs-attr">attr_name</span>: <span class="hljs-string">&#x27;href&#x27;</span>,
        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;链接&#x27;</span>
    }
});
</div></code></pre>
</li>
<li>
<p>添加类名（对象方式）<br>
<code>v-bind:class=&quot;{类名: 表达式, 类名: 表达式, ...}&quot;</code></p>
<blockquote>
<p>当表达式结果为 <code>true</code> 时添加对应的类名</p>
</blockquote>
</li>
<li>
<p>添加类名（数组方式）<br>
<code>v-bind:class=&quot;[{类名: 表达式, 类名: 表达式, ...}, 表达式, '类名', ...]&quot;</code></p>
<blockquote>
<p>数组中可以写 <code>对象</code>、<code>表达式</code>，也可以直接写 <code>类名</code></p>
</blockquote>
</li>
<li>
<p>通过 <code>v-bind</code> 指令添加的类名与通过 <code>class</code> 属性添加的类名共存。</p>
</li>
<li>
<p>添加样式：<code>v-bind:style=&quot;表达式&quot;</code></p>
<ul>
<li>
<p>表达式有以下写法</p>
<ul>
<li>
<p><code>{'属性名': '属性值', '属性名': '属性值', ...}</code></p>
</li>
<li>
<p><code>{属性名, 属性名, ...}</code><br>
属性名为 <code>data</code> 对象中的属性名（获取对应的变量值）</p>
</li>
<li>
<p><code>{'属性名': ['属性值', '属性值', ...]}</code><br>
多重值，主要用于兼容（自动选择浏览器支持的最后一个值）</p>
</li>
<li>
<p>直接写 <code>data</code> 对象中的属性名（获取对应的对象）</p>
</li>
</ul>
</li>
<li>
<p>若 <code>属性名</code> 有 <code>-</code>，需要使用驼峰命名法</p>
</li>
<li>
<p>通过 <code>v-bind</code> 指令添加的样式会根据实际自动添加兼容性前缀（<code>-webkit-</code>、<code>-moz-</code>、<code>-ms-</code>、<code>-o-</code>、）</p>
</li>
</ul>
</li>
<li>
<p><code>v-bind:</code> 可缩写为 <code>:</code></p>
<pre><code class="language-html"><div><span class="hljs-comment">&lt;!-- 完整 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 缩写 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:</span>[<span class="hljs-attr">key</span>]=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
</div></code></pre>
</li>
</ul>
<h2 id="v-on">v-on</h2>
<h3 id="简介-2">简介</h3>
<p><code>v-on</code> 指令用于绑定监听事件</p>
<h3 id="用法-1">用法</h3>
<ul>
<li>
<p><code>v-on:事件名.事件修饰符=&quot;表达式&quot;</code></p>
</li>
<li>
<p>当表达式为调用事件处理方法，且不需要传递参数时，可省略方法名后的 <code>()</code>（第一个参数为原生事件对象）。</p>
</li>
<li>
<p>当表达式为调用事件处理方法，且需要传递参数时，可通过形参 <code>$event</code> 传递原生事件对象。</p>
</li>
<li>
<p><code>v-on:</code> 可缩写为 <code>@</code></p>
<pre><code class="language-html"><div><span class="hljs-comment">&lt;!-- 完整 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 缩写 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> @[<span class="hljs-attr">event</span>]=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
</div></code></pre>
</li>
</ul>
<h3 id="事件修饰符">事件修饰符</h3>
<p><code>事件修饰符</code> 是可选的，有以下值可用（多个值可串联使用）：</p>
<ul>
<li>
<p><code>.stop</code> - 阻止冒泡</p>
</li>
<li>
<p><code>.prevent</code> - 阻止默认行为</p>
</li>
<li>
<p><code>.capture</code> - 使用事件捕获模式</p>
</li>
<li>
<p><code>.self</code> - 只在 <code>event.target</code> 是当前元素时才触发</p>
</li>
<li>
<p><code>.once</code> - 事件将只会触发一次</p>
</li>
<li>
<p><code>.passive</code> - 跳过检查是否阻止冒泡、是否阻止默认行为，可提升移动端 scroll 事件的性能</p>
<blockquote>
<p><code>.passive</code> 会告诉浏览器不想阻止事件的默认行为，因此不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用，<br>
否则 <code>.prevent</code> 将会被忽略，同时浏览器可能展示一个警告。</p>
</blockquote>
</li>
</ul>
<h3 id="按键修饰符">按键修饰符</h3>
<ul>
<li>
<p>在监听键盘事件时，可能需要判断按下的按键。</p>
</li>
<li>
<p>Vue 允许为 <code>v-on</code> 在监听 <code>键盘事件</code> 时添加按键修饰符：</p>
<pre><code class="language-html"><div><span class="hljs-comment">&lt;!-- 只有在 key 是 Enter 时调用事件处理方法 submit() --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.enter</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>
</div></code></pre>
</li>
<li>
<p>可以直接将 <code>KeyboardEvent.key</code> 暴露的任意有效按键名转换为 <code>kebab-case</code> 来作为修饰符：</p>
<pre><code class="language-html"><div><span class="hljs-comment">&lt;!-- 只有在 $event.key 等于 PageDown 时调用事件处理方法 onPageDown() --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.page-down</span>=<span class="hljs-string">&quot;onPageDown&quot;</span>&gt;</span>
</div></code></pre>
</li>
<li>
<p>按键码</p>
<ul>
<li>
<p>使用 <code>keyCode attribute</code> 是允许的</p>
<blockquote>
<p><code>keyCode</code> 的事件用法已经被废弃了并可能不会被最新的浏览器支持</p>
</blockquote>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.13</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>
</div></code></pre>
</li>
<li>
<p>为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名</p>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> - 捕获 <code>删除</code> 和 <code>退格</code> 键</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="系统修饰键">系统修饰键</h3>
<ul>
<li>
<p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<blockquote>
<p><strong>注意</strong></p>
<p>在 Mac 系统键盘上，<code>meta</code> 对应 command 键 (<code>⌘</code>)。<br>
在 Windows 系统键盘 <code>meta</code> 对应 Windows 徽标键 (<code>⊞</code>)。<br>
在 Sun 操作系统键盘上，<code>meta</code> 对应实心宝石键 (<code>◆</code>)。<br>
在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品（例如 Knight、space-cadet），<code>meta</code> 被标记为“META”。<br>
在 Symbolics 键盘上，<code>meta</code> 被标记为“META”或者“Meta”。</p>
<p><code>修饰键</code> 与 <code>常规按键</code> 不同，在和 <code>keyup</code> 事件一起用时，事件触发时 <code>修饰键</code> 必须处于 <code>按下</code> 状态。<br>
换句话说，只有在按住 <code>Ctrl</code> 的情况下释放其它按键，才能触发 <code>keyup.ctrl</code>。</p>
</blockquote>
<pre><code class="language-html"><div><span class="hljs-comment">&lt;!-- Alt + C --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.alt.67</span>=<span class="hljs-string">&quot;clear&quot;</span>&gt;</span>

<span class="hljs-comment">&lt;!-- Ctrl + 点击 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-on:click.ctrl</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
</li>
<li>
<p><code>.exact</code> 修饰符（控制由精确的系统修饰符组合触发的事件）</p>
<pre><code class="language-html"><div><span class="hljs-comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click.ctrl</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click.ctrl.exact</span>=<span class="hljs-string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click.exact</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
</li>
<li>
<p>鼠标按钮修饰符（限制处理函数仅响应特定的鼠标按钮）</p>
<ul>
<li><code>.left</code> - 左键</li>
<li><code>.right</code> - 右键</li>
<li><code>.middle</code> - 中建</li>
</ul>
</li>
</ul>
<h2 id="v-if-条件渲染">v-if（条件渲染）</h2>
<h3 id="简介-3">简介</h3>
<ul>
<li><code>v-if</code> 指令用于条件性地渲染一块内容</li>
<li>当指令的表达式值为 <code>true</code> 时渲染内容</li>
<li>当指令的表达式值为 <code>false</code> 时 DOM 元素被移除</li>
</ul>
<h3 id="用法-2">用法</h3>
<ul>
<li>
<p><code>v-if=&quot;表达式&quot;</code></p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span>条件渲染<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
</div></code></pre>
</li>
<li>
<p>可以使用 <code>v-else</code> 添加一个 <code>else</code> 块</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span>条件渲染（if）<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else</span>&gt;</span>条件渲染（else）<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
</div></code></pre>
</li>
<li>
<p>可以使用 <code>v-else-if</code>，充当 <code>v-if</code> 的 <code>else-if</code> 块（可以连续使用）</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>Not A / B / C<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
</li>
</ul>
<h3 id="注意-1">注意</h3>
<ul>
<li>在 <code>v-if</code> ... <code>v-else-if</code> ... <code>v-else</code> 之间不能加入非 <code>v-if</code> 指令的元素。</li>
<li>类似于 <code>v-else</code>，<code>v-else-if</code> 也必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素之后。</li>
</ul>
<h2 id="v-show-条件显示">v-show（条件显示）</h2>
<h3 id="简介-4">简介</h3>
<p>另一个用于根据条件展示元素的选项是 <code>v-show</code> 指令，用法大致一样。<br>
不同的是：带有 <code>v-show</code> 的元素始终会被渲染并保留在 DOM 中，<code>v-show</code> 只是简单地切换元素的 CSS 的 <code>display</code> 属性。</p>
<h3 id="用法-3">用法</h3>
<ul>
<li>
<p><code>v-show=&quot;表达式&quot;</code></p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span>条件显示<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
</div></code></pre>
</li>
</ul>
<h3 id="注意-2">注意</h3>
<ul>
<li><code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>。</li>
</ul>
<h2 id="v-for-列表渲染">v-for（列表渲染）</h2>
<h3 id="简介-5">简介</h3>
<ul>
<li>可以用 <code>v-for</code> 指令基于一个数组来渲染一个列表，类似于 <code>forEach()</code>。</li>
<li><code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法（<code>items</code> - 源数据数组，<code>item</code> - 被迭代的数组元素的别名）。</li>
</ul>
<h3 id="用法-4">用法</h3>
<ul>
<li>
<p><code>v-for=&quot;item in items&quot;</code></p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in info&quot;</span> <span class="hljs-attr">v-bind:data-id</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>{{ item.message }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
<pre><code class="language-javascript"><div><span class="hljs-keyword">new</span> Vue({
    ...
    data: {
        <span class="hljs-attr">info</span>: [
            { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;一&#x27;</span> },
            { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;二&#x27;</span> },
            { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;三&#x27;</span> },
            { <span class="hljs-attr">id</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;四&#x27;</span> }
        ]
    }
});
</div></code></pre>
<pre><code class="language-html"><div><span class="hljs-comment">&lt;!-- 结果 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-1&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>二<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>三<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>四<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
</li>
<li>
<p>在 <code>v-for</code> 块中，可以访问所有父作用域的 <code>property</code>。</p>
</li>
<li>
<p><code>v-for</code> 还支持一个可选的第二个参数（当前项的索引）。</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in items&quot;</span>&gt;</span>{{ index }} - {{ item.message }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
<pre><code class="language-html"><div><span class="hljs-comment">&lt;!-- 结果 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-2&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>0 - 一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>1 - 二<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>2 - 三<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>3 - 四<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
</li>
<li>
<p>可以用 <code>of</code> 替代 <code>in</code> 作为分隔符（它更接近 JavaScript 迭代器的语法）</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item of info&quot;</span>&gt;</span>{{ item.message }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
</li>
<li>
<p>可以用 <code>v-for</code> 来遍历一个对象的 <code>property</code></p>
<blockquote>
<p><code>object</code> 为对象，<code>value</code> 为属性值。</p>
</blockquote>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;value in object&quot;</span>&gt;</span>{{ value }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
<blockquote>
<p>可以提供第二个参数作为对象的属性名</p>
</blockquote>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, name) in object&quot;</span>&gt;</span>{{ name }}: {{ value }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
<blockquote>
<p>还可以提供第三个参数作为索引</p>
</blockquote>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, name, index) in object&quot;</span>&gt;</span>{{ index }} - {{ name }}: {{ value }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
</li>
</ul>
<h3 id="维护状态">维护状态</h3>
<ul>
<li>
<p>当 Vue 更新使用 <code>v-for</code> 渲染的元素列表时，它默认使用 <code>就地更新</code> 的策略。</p>
</li>
<li>
<p>如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。</p>
</li>
<li>
<p>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。</p>
</li>
<li>
<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一 <code>key</code> 属性：</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
</li>
<li>
<p>尽可能在使用 <code>v-for</code> 时提供 <code>key</code> 属性，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。<br>
因为它是 Vue 识别节点的一个通用机制，<code>key</code> 并不仅与 <code>v-for</code> 特别关联，它还具有其它用途。</p>
</li>
<li>
<p>不要使用对象或数组之类的非基本类型值作为 <code>v-for</code> 的 <code>key</code>，需要使用 <code>字符串</code> 或 <code>数值</code> 类型的值。</p>
</li>
</ul>
<h3 id="数组更新检测">数组更新检测</h3>
<h4 id="变更方法">变更方法</h4>
<p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。<br>
这些被包裹过的方法包括：</p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
<h4 id="注意事项">注意事项</h4>
<ul>
<li>
<p>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。</p>
</li>
<li>
<p><code>data</code> 对象中的数据通过绑定 <code>getter</code> 和 <code>setter</code> 观察数据变化并同步更新到页面中，<br>
但是数组中的元素没有 <code>getter</code> 和 <code>setter</code>，所以如果通过下标更新数组数据，页面数据不会跟随改变。</p>
</li>
<li>
<p>如果需要手动更新数组数据并同步到页面中，有以下的方式：</p>
<ul>
<li>
<p>使用被 Vue 包裹过的方法</p>
</li>
<li>
<p>直接替换整个数组（可使用 <code>展开</code> 保留原有数据）</p>
</li>
<li>
<p>使用 Vue 对象或 Vue 的静态 <code>set</code>、<code>delete</code> 方法</p>
<blockquote>
<p><code>vm</code> 为实例化的 Vue 对象</p>
</blockquote>
<ul>
<li><code>vm.$set(vm.数组, 下标，值)</code></li>
<li><code>vm.$delete(vm.数组, 下标)</code></li>
<li><code>Vue.set(vm.数组, 下标, 值)</code></li>
<li><code>Vue.delete(vm.数组, 下标)</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>如果需要手动更新对象数据并同步到页面中，有以下的方式：</p>
<ul>
<li>
<p>直接替换整个对象（可使用 <code>展开</code> 保留原有数据）</p>
</li>
<li>
<p>使用 Vue 对象或 Vue 的静态 <code>set</code>、<code>delete</code> 方法</p>
<blockquote>
<p><code>vm</code> 为实例化的 Vue 对象</p>
</blockquote>
<ul>
<li><code>vm.$set(vm.对象, 属性名，属性值)</code></li>
<li><code>vm.$delete(vm.对象, 属性名)</code></li>
<li><code>Vue.set(vm.对象, 属性名, 属性值)</code></li>
<li><code>Vue.delete(vm.对象, 属性名)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="v-model-表单输入绑定">v-model（表单输入绑定）</h2>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/forms.html">https://cn.vuejs.org/v2/guide/forms.html</a></p>
</blockquote>
<h3 id="基础用法">基础用法</h3>
<ul>
<li>
<p>可以用 <code>v-model</code> 指令在表单元素（<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>）上创建双向数据绑定。</p>
<ul>
<li>它会根据控件类型自动选取正确的方法来更新元素。</li>
<li>尽管有些神奇，但 v-model 本质上是语法糖。</li>
<li>它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</li>
</ul>
</li>
<li>
<p><code>v-model</code> 总是将 Vue 实例的数据作为数据来源，会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> 属性的初始值。<br>
因此应该通过 JavaScript 在组件的 <code>data</code> 对象中声明初始值。</p>
</li>
<li>
<p><code>v-model</code> 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ul>
<li><code>text</code> 和 <code>textarea</code> 元素使用 <code>value</code> 属性和 <code>input</code> 事件</li>
<li><code>checkbox</code> 和 <code>radio</code> 元素使用 <code>checked</code> 属性和 <code>change</code> 事件</li>
<li><code>select</code> 元素使用 <code>value</code> 属性和 <code>change</code> 事件</li>
<li>对于需要使用输入法（例如中文、日文、韩文等）的语言，<code>v-model</code> 不会在输入法组合文字过程中得到更新。<br>
如果要处理这个过程，需要使用 <code>input</code> 事件。</li>
</ul>
</li>
</ul>
<h3 id="修饰符">修饰符</h3>
<ul>
<li>
<p><code>.lazy</code></p>
<ul>
<li>
<p>在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步（除了输入法组合文字时）。</p>
</li>
<li>
<p>可以添加 <code>.lazy</code> 修饰符，从而转为在 <code>change</code> 事件之后进行同步。</p>
<pre><code class="language-html"><div><span class="hljs-comment">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span>
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><code>.number</code></p>
<ul>
<li>
<p>如果想自动将用户的输入值转为数值类型，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符。</p>
</li>
<li>
<p>这通常很有用，因为即使在 <code>type=&quot;number&quot;</code> 时，HTML 输入元素的值也总会返回字符串。</p>
</li>
<li>
<p>如果这个值无法被 <code>parseFloat()</code> 解析，则会返回原始的值。</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span>&gt;</span>
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><code>.trim</code></p>
<ul>
<li>
<p>如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.trim</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span>
</div></code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="事件处理方法">事件处理方法</h1>
<h3 id="用法-5">用法</h3>
<pre><code class="language-javascript"><div><span class="hljs-keyword">new</span> Vue({
  ...
  methods: {
    方法名: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">参数</span>) </span>{
      ...
    },
    方法名: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">参数</span>) </span>{
      ...
    },
    ...
  }
});
</div></code></pre>
<h3 id="注意-3">注意</h3>
<ul>
<li>事件处理方法中的 <code>this</code> 指向当前的 Vue 对象。</li>
</ul>
<h1 id="计算属性">计算属性</h1>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/computed.html">https://cn.vuejs.org/v2/guide/computed.html</a></p>
</blockquote>
<h2 id="简介-6">简介</h2>
<p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。<br>
在模板中放入太多的逻辑会让模板过重且难以维护。<br>
所以，对于任何复杂逻辑，都应当使用计算属性。</p>
<h2 id="基础用法-1">基础用法</h2>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>原始内容：{{ msgOrigin }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>新的内容：{{ msgNew }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<pre><code class="language-javascript"><div><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({
    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
    <span class="hljs-attr">data</span>: {
        <span class="hljs-attr">msgOrigin</span>: <span class="hljs-string">&#x27;example&#x27;</span>
    },
    <span class="hljs-attr">computed</span>: {
        <span class="hljs-attr">msgNew</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">// this 指向 vm 实例</span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.msgOrigin.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);
        }
    }
});
</div></code></pre>
<pre><code class="language-html"><div><span class="hljs-comment">&lt;!-- 结果 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>原始内容：example<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>新的内容：elpmaxe<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<h2 id="setter">setter</h2>
<p>计算属性默认只有 <code>getter</code>，如果需要，可以提供一个 <code>setter</code></p>
<pre><code class="language-javascript"><div><span class="hljs-keyword">new</span> Vue({
    ...
    computed: {
        <span class="hljs-attr">example</span>: {
            <span class="hljs-comment">// getter</span>
            <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> ...
            },
            <span class="hljs-comment">// setter</span>
            <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                ...
            }
        }
    }
});
</div></code></pre>
<h1 id="侦听器">侦听器</h1>
<h2 id="简介-7">简介</h2>
<p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。<br>
因此 Vue 通过 <code>watch</code> 选项提供了一个更通用的方法，来响应数据的变化。<br>
当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p>
<h2 id="用法-6">用法</h2>
<pre><code class="language-javascript"><div><span class="hljs-keyword">new</span> Vue({
    ...
    watch: {
        侦听属性名: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newValue, oldValue</span>) </span>{
            ...
        }
    }
});
</div></code></pre>
<h1 id="组件">组件</h1>
<h2 id="简介-8">简介</h2>
<p>组件是可复用的 Vue 实例，且带有一个名字。<br>
可以在一个通过 <code>new Vue</code> 创建的 Vue 根实例中，把这个组件作为自定义元素来使用。</p>
<h2 id="基础用法-2">基础用法</h2>
<h3 id="定义">定义</h3>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 方式一（全局）</span>

Vue.component(<span class="hljs-string">&#x27;组件名称&#x27;</span>, {
    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;内容&#x27;</span> <span class="hljs-comment">// 例如：&lt;h2&gt;这是一个标题&lt;/h2&gt;</span>
});

<span class="hljs-comment">// 方式二（局部）</span>

<span class="hljs-keyword">new</span> Vue({
    ...
    components: {
        <span class="hljs-string">&#x27;组件名称&#x27;</span>: {
            <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;内容&#x27;</span>
        }
    }
});
</div></code></pre>
<h3 id="使用">使用</h3>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">组件名称</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">组件名称</span>&gt;</span>
</div></code></pre>
<h3 id="注意-4">注意</h3>
<ul>
<li>
<p>组件模板（<code>template</code>）有且只有一个根节点。</p>
</li>
<li>
<p>组件中可以有子组件，且父组件可调用子组件。</p>
<pre><code class="language-javascript"><div><span class="hljs-keyword">new</span> Vue({
    ...
    components: {
        <span class="hljs-string">&#x27;组件名称&#x27;</span>: {
            <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;内容&#x27;</span>,
            <span class="hljs-string">&#x27;组件名称&#x27;</span>: {
                <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;内容&#x27;</span>
            }
        }
    }
});
</div></code></pre>
</li>
</ul>
<h2 id="data">data</h2>
<p>一个组件的 <code>data</code> 选项必须是一个函数，因此每个实例可以维护一份被返回对象的 <code>独立</code> 的拷贝。<br>
否则，进行操作时可能会影响到其它所有的实例（因为对象是引用类型）。</p>
<pre><code class="language-javascript"><div>Vue.component(<span class="hljs-string">&#x27;组件名称&#x27;</span>, {
    ...
    data: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> {
            属性名<span class="hljs-number">1</span>: 属性值<span class="hljs-number">1</span>,
            属性名<span class="hljs-number">2</span>: 属性值<span class="hljs-number">2</span>,
            ...
        }
    }
});
</div></code></pre>
<h2 id="通过-prop-向子组件传递数据">通过 Prop 向子组件传递数据</h2>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/components-props.html">https://cn.vuejs.org/v2/guide/components-props.html</a>)</p>
</blockquote>
<h3 id="简介-9">简介</h3>
<p>Prop 是在组件上注册的一些自定义 attribute。</p>
<h3 id="使用方式">使用方式</h3>
<p>当一个值传递给一个 <code>prop</code> attribute 的时候，它就变成了那个组件实例的一个 <code>property</code>。</p>
<pre><code class="language-javascript"><div>Vue.component(<span class="hljs-string">&#x27;blog-post&#x27;</span>, {
    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;title&#x27;</span>],
    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;h3&gt;{{ title }}&lt;/h3&gt;&#x27;</span>
});
</div></code></pre>
<p>一个组件默认可以拥有任意数量的 <code>prop</code>，任何值都可以传递给任何 <code>prop</code>。<br>
一个 <code>prop</code> 被注册之后，就可以像这样把数据作为一个自定义 <code>attribute</code> 传递到子组件：</p>
<pre><code class="language-html"><div><span class="hljs-comment">&lt;!-- 静态 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;标题1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;标题2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 动态 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;data 中的属性名&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;data 中的属性名&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span>
</div></code></pre>
<h3 id="单向数据流">单向数据流</h3>
<p>所有的 <code>prop</code> 都使得其父子 <code>prop</code> 之间形成了一个单向下行绑定：</p>
<ul>
<li>父级 prop 的更新会向下流动到子组件中，但是反过来则不行。</li>
<li>这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</li>
</ul>
<p>额外的，每次父级组件发生变更时，子组件中所有的 <code>prop</code> 都将会刷新为最新的值。<br>
这意味着不应该在一个子组件内部改变 <code>prop</code>，否则 Vue 会在浏览器的控制台中发出警告。</p>
<h3 id="prop-验证">Prop 验证</h3>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81">https://cn.vuejs.org/v2/guide/components-props.html#Prop-验证</a></p>
</blockquote>
<h2 id="访问元素-组件">访问元素 &amp; 组件</h2>
<h3 id="访问子组件实例或子元素-refs">访问子组件实例或子元素（$refs）</h3>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E6%88%96%E5%AD%90%E5%85%83%E7%B4%A0">https://cn.vuejs.org/v2/guide/components-edge-cases.html#访问子组件实例或子元素</a></p>
</blockquote>
<p>尽管存在 <code>prop</code> 和事件，有的时候仍可能需要在 JavaScript 里直接访问一个子组件。<br>
为了达到这个目的，可以通过 <code>ref</code> 这个 <code>attribute</code> 为子组件赋予一个 ID 引用，例如：</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">base-input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;usernameInput&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">base-input</span>&gt;</span>
</div></code></pre>
<p>在已经定义了这个 <code>ref</code> 的组件里，可以使用：</p>
<pre><code class="language-javascript"><div><span class="hljs-built_in">this</span>.$refs.usernameInput
</div></code></pre>
<p>来访问这个 <code>&lt;base-input&gt;</code> 实例，以便不时之需（例如程序化地从一个父级组件聚焦这个输入框）。<br>
该 <code>&lt;base-input&gt;</code> 组件也可以使用一个类似的 <code>ref</code> 提供对内部这个指定元素的访问，例如：</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;input&quot;</span>&gt;</span>
</div></code></pre>
<p>甚至可以通过其父级组件定义方法：</p>
<pre><code class="language-javascript"><div><span class="hljs-keyword">new</span> Vue({
    ...
    methods: {
        <span class="hljs-comment">// 从父级组件聚焦输入框</span>
        <span class="hljs-attr">focus</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">this</span>.$refs.input.focus();
        }
    }
});
</div></code></pre>
<p>这样就允许父级组件通过下面的代码聚焦 <code>&lt;base-input&gt;</code> 里的输入框：</p>
<pre><code class="language-javascript"><div><span class="hljs-built_in">this</span>.$refs.usernameInput.focus()
</div></code></pre>
<blockquote>
<p>通过 <code>$refs</code> 获取同名 <code>ref</code> 的普通元素时，只能获取最后一个。<br>
当 <code>ref</code> 和 <code>v-for</code> 一起使用的时候，得到的 <code>ref</code> 将会是一个包含了对应数据源的这些子组件的数组。</p>
<p><code>$refs</code> 只会在组件渲染完成之后生效，并且它们不是响应式的。<br>
这仅作为一个用于直接操作子组件的“逃生舱”，应该避免在模板或计算属性中访问 <code>$refs</code>。</p>
</blockquote>
<h3 id="触发父组件的自定义事件-emit">触发父组件的自定义事件（$emit）</h3>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/api/#vm-emit">https://cn.vuejs.org/v2/api/#vm-emit</a></p>
</blockquote>
<h4 id="使用方式-1">使用方式</h4>
<ul>
<li>
<p><code>vm.$emit( eventName, […args] )</code></p>
<ul>
<li>触发当前实例上的事件</li>
<li>附加参数都会传给监听器回调</li>
</ul>
</li>
<li>
<p><code>vm.$on( eventName, fn )</code></p>
<ul>
<li>监听事件 <code>eventName</code> 触发后调用 <code>fn()</code></li>
</ul>
</li>
</ul>
<h4 id="例子">例子</h4>
<pre><code class="language-javascript"><div>Vue.component(<span class="hljs-string">&#x27;welcome-btn&#x27;</span>, {
    <span class="hljs-comment">// 事件名：welcome</span>
    <span class="hljs-comment">// 参数：张三</span>
    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;button v-on:click=&quot;$emit(&#x27;welcome&#x27;, &#x27;张三&#x27;)&quot;&gt;欢迎&lt;/button&gt;`</span>
});

<span class="hljs-keyword">new</span> Vue({
    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#emit-example-simple&#x27;</span>,
    <span class="hljs-attr">methods</span>: {
        <span class="hljs-comment">// 事件处理方法</span>
        <span class="hljs-attr">sayHi</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
            alert(<span class="hljs-string">`您好，<span class="hljs-subst">${name}</span>！`</span>)
        }
    }
});
</div></code></pre>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;emit-example-simple&quot;</span>&gt;</span>
    <span class="hljs-comment">&lt;!--
        事件名：welcome
        回调（事件处理方法）：sayHi()
    --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-btn</span> <span class="hljs-attr">v-on:welcome</span>=<span class="hljs-string">&quot;sayHi&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">welcome-btn</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<h2 id="插槽-slot">插槽（slot）</h2>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/components-slots.html">https://cn.vuejs.org/v2/guide/components-slots.html</a></p>
</blockquote>
<h3 id="默认插槽">默认插槽</h3>
<h4 id="例子-1">例子</h4>
<p>模板</p>
<blockquote>
<p>如果没有包含一个 <code>&lt;slot&gt;</code> 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。</p>
</blockquote>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-link&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
</div></code></pre>
<p>页面</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/profile&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  Your Profile
<span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span>
</div></code></pre>
<p>结果</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/profile&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-link&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  Your Profile
<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
</div></code></pre>
<h3 id="具名插槽">具名插槽</h3>
<h4 id="例子-2">例子</h4>
<p>模板</p>
<blockquote>
<p><code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：<code>name</code><br>
这个 attribute 可以用来定义额外的插槽<br>
一个不带 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名称 <code>default</code></p>
</blockquote>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>页面</p>
<blockquote>
<p>在向具名插槽提供内容的时候，可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指令，并以 <code>v-slot</code> 的参数的形式提供其名称。<br>
<code>&lt;template&gt;</code> 元素中的所有内容都将会被传入相应的插槽。<br>
任何没有被包裹在带有 <code>v-slot</code> 的 <code>&lt;template&gt;</code> 中的内容都会被视为默认插槽的内容。</p>
</blockquote>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here&#x27;s some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span>
</div></code></pre>
<blockquote>
<p>仍然可以在一个 <code>&lt;template&gt;</code> 中包裹默认插槽的内容：</p>
</blockquote>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here&#x27;s some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span>
</div></code></pre>
<p>结果</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here&#x27;s some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<h4 id="注意-5">注意</h4>
<ul>
<li><code>v-slot</code> 只能添加在 <code>&lt;template&gt;</code> 上（只有一种例外情况），这一点和已经废弃的 <code>slot</code> attribute 不同。</li>
</ul>
<h3 id="作用域插槽-slot-scope">作用域插槽（slot-scope）</h3>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">https://cn.vuejs.org/v2/guide/components-slots.html#作用域插槽</a></p>
</blockquote>
<h2 id="动态组件-异步组件">动态组件 &amp; 异步组件</h2>
<h3 id="动态组件">动态组件</h3>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">v-bind:is</span>=<span class="hljs-string">&quot;组件名称&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
</div></code></pre>
<h2 id="transition-组件">transition 组件</h2>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/transitions.html">https://cn.vuejs.org/v2/guide/transitions.html</a></p>
</blockquote>
<h3 id="单元素-组件的过渡-transition">单元素 / 组件的过渡（transition）</h3>
<h4 id="简介-10">简介</h4>
<p>Vue 提供了 <code>transition</code> 的封装组件，在以下的情形中，可以给任何元素和组件添加进入 / 离开过渡：</p>
<ul>
<li>条件渲染 (使用 <code>v-if)</code></li>
<li>条件显示 (使用 <code>v-show</code>)</li>
<li>动态组件</li>
<li>组件根节点</li>
</ul>
<p>当插入或删除包含在 <code>transition</code> 组件中的元素时，Vue 将会做以下处理：</p>
<ul>
<li>自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加 / 删除 CSS 类名。</li>
<li>如果过渡组件提供了 <code>JavaScript 钩子函数</code>，这些钩子函数将在恰当的时机被调用。</li>
<li>如果没有找到 <code>JavaScript 钩子函数</code> 并且也没有检测到 CSS 过渡或动画，DOM 操作（插入 / 删除）在下一帧会立即执行。<br>
（注意：此指浏览器逐帧动画机制，和 Vue 的 <code>nextTick</code> 概念不同）</li>
</ul>
<h4 id="过渡的类名">过渡的类名</h4>
<p>在 <code>进入</code> / <code>离开</code> 的过渡中，会有 6 个 <code>class</code> 切换：</p>
<ul>
<li>
<p><code>v-enter</code></p>
<ul>
<li>定义进入过渡的开始状态。</li>
<li>在元素被插入之前生效，在元素被插入之后的下一帧移除。</li>
</ul>
</li>
<li>
<p><code>v-enter-active</code></p>
<ul>
<li>定义进入过渡生效时的状态。</li>
<li>在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡动画完成之后移除。</li>
<li>这个类可以被用来定义进入过渡的过程时间、延迟和曲线函数。</li>
</ul>
</li>
<li>
<p><code>v-enter-to</code></p>
<ul>
<li>定义进入过渡的结束状态（2.1.8 版及以上）。</li>
<li>在元素被插入之后下一帧生效（与此同时 <code>v-enter</code> 被移除），在过渡动画完成之后移除。</li>
</ul>
</li>
<li>
<p><code>v-leave</code></p>
<ul>
<li>定义离开过渡的开始状态。</li>
<li>在离开过渡被触发时立刻生效，下一帧被移除。</li>
</ul>
</li>
<li>
<p><code>v-leave-active</code></p>
<ul>
<li>定义离开过渡生效时的状态。</li>
<li>在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡动画完成之后移除。</li>
<li>这个类可以被用来定义离开过渡的过程时间、延迟和曲线函数。</li>
</ul>
</li>
<li>
<p><code>v-leave-to</code></p>
<ul>
<li>定义离开过渡的结束状态（2.1.8 版及以上）。</li>
<li>在离开过渡被触发之后下一帧生效（与此同时 <code>v-leave</code> 被删除），在过渡动画完成之后移除。</li>
</ul>
</li>
</ul>
<p><img src="./assets/note-vue/transition.png" alt="过渡"></p>
<p>对于这些在过渡中切换的类名，如果使用一个没有名字的 <code>&lt;transition&gt;</code>，则 <code>v-</code> 是这些类名的 <code>默认前缀</code>。<br>
如果使用了 <code>&lt;transition name=&quot;example&quot;&gt;</code>，前缀会变为 <code>example-</code>（<code>v-enter</code> 变为 <code>example-enter</code>）。<br>
<code>v-enter-active</code> 和 <code>v-leave-active</code> 可以控制进入 / 离开过渡的不同的缓和曲线。</p>
<h4 id="javascript-钩子函数">JavaScript 钩子函数</h4>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/transitions.html#JavaScript-%E9%92%A9%E5%AD%90">https://cn.vuejs.org/v2/guide/transitions.html#JavaScript-钩子</a></p>
</blockquote>
<p>可以在 <code>attribute</code> 中声明 JavaScript 钩子（<code>v-on:事件=&quot;事件处理函数&quot;</code>）</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">transition</span>
    <span class="hljs-attr">v-on:before-enter</span>=<span class="hljs-string">&quot;beforeEnter&quot;</span> <span class="hljs-attr">v-on:enter</span>=<span class="hljs-string">&quot;enter&quot;</span>
    <span class="hljs-attr">v-on:after-enter</span>=<span class="hljs-string">&quot;afterEnter&quot;</span> <span class="hljs-attr">v-on:enter-cancelled</span>=<span class="hljs-string">&quot;enterCancelled&quot;</span>
    <span class="hljs-attr">v-on:before-leave</span>=<span class="hljs-string">&quot;beforeLeave&quot;</span> <span class="hljs-attr">v-on:leave</span>=<span class="hljs-string">&quot;leave&quot;</span>
    <span class="hljs-attr">v-on:after-leave</span>=<span class="hljs-string">&quot;afterLeave&quot;</span> <span class="hljs-attr">v-on:leave-cancelled</span>=<span class="hljs-string">&quot;leaveCancelled&quot;</span>
&gt;</span>
    ...
<span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span>
</div></code></pre>
<p>这些钩子函数可以结合 CSS <code>transitions</code> / <code>animations</code> 使用，也可以单独使用。</p>
<blockquote>
<p>当只用 JavaScript 过渡的时候，在 <code>enter</code> 和 <code>leave</code> 函数中必须使用 <code>done</code> 进行回调。<br>
否则，它们将被同步调用，过渡会立即完成。</p>
<p>推荐对于仅使用 JavaScript 过渡的元素添加 <code>v-bind:css=&quot;false&quot;</code>，Vue 会跳过 CSS 的检测。<br>
这也可以避免过渡过程中 CSS 的影响。</p>
</blockquote>
<h3 id="列表的进入-离开过渡-transition-group">列表的进入 / 离开过渡（transition-group）</h3>
<h4 id="简介-11">简介</h4>
<p>特点：</p>
<ul>
<li>不同于 <code>&lt;transition&gt;</code>，它会以一个真实元素呈现：默认为一个 <code>&lt;span&gt;</code>（可以通过 <code>tag</code> 属性更换为其他元素）。</li>
<li><code>过渡模式</code> 不可用，因为不再相互切换特有的元素。</li>
<li>内部元素需要提供唯一的 <code>key</code> 属性值。</li>
<li>CSS 过渡的类将会应用在内部的元素中，而不是这个组 / 容器本身。</li>
</ul>
<h1 id="过滤器">过滤器</h1>
<h2 id="定义过滤器">定义过滤器</h2>
<h3 id="局部">局部</h3>
<pre><code class="language-javascript"><div><span class="hljs-keyword">new</span> Vue({
    ...
    filters: {
        <span class="hljs-comment">// capitalize：过滤器名称</span>
        <span class="hljs-comment">// value：原始值</span>
        <span class="hljs-comment">// return：返回过滤操作后的内容</span>
        <span class="hljs-attr">capitalize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
            <span class="hljs-keyword">if</span> (!value) {
                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;
            }
            <span class="hljs-keyword">return</span> value.charAt(<span class="hljs-number">0</span>).toUpperCase() + value.substr(<span class="hljs-number">1</span>);
        },
        <span class="hljs-comment">// substr：过滤器名称</span>
        <span class="hljs-comment">// value：原始值</span>
        <span class="hljs-comment">// start、length：参数</span>
        <span class="hljs-comment">// return：返回过滤操作后的内容</span>
        <span class="hljs-attr">substr</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, start, length</span>) </span>{
            <span class="hljs-keyword">if</span> (!value) {
                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;
            }
            <span class="hljs-keyword">return</span> value.substr(start, length);
        }
    }
});
</div></code></pre>
<h3 id="全局">全局</h3>
<pre><code class="language-javascript"><div>Vue.filter(<span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">if</span> (!value) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;
    }
    <span class="hljs-keyword">return</span> value.charAt(<span class="hljs-number">0</span>).toUpperCase() + value.substr(<span class="hljs-number">1</span>);
});

<span class="hljs-keyword">new</span> Vue({
    ...
});
</div></code></pre>
<h2 id="使用-1">使用</h2>
<h3 id="普通方式">普通方式</h3>
<pre><code class="language-html"><div><span class="hljs-comment">&lt;!-- 方式一 --&gt;</span>
{{ 原始值 | 过滤器名称 }}

<span class="hljs-comment">&lt;!-- 方式二 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:</span>属性名=<span class="hljs-string">&quot;原始值 | 过滤器名称&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<h3 id="串联">串联</h3>
<pre><code class="language-html"><div>{{ 原始值 | 过滤器1 | 过滤器2 | ... }}
</div></code></pre>
<p>原始值 -&gt; 过滤器1 -&gt; 过滤器2 -&gt; ...</p>
<h3 id="接收参数">接收参数</h3>
<pre><code class="language-html"><div>{{ 原始值 | 过滤器名称(参数1, 参数2, ...) }}
</div></code></pre>
<pre><code class="language-javascript"><div>Vue.filter(<span class="hljs-string">&#x27;过滤器名称&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, 参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span>, ...</span>) </span>{
    <span class="hljs-keyword">return</span> ...
});
</div></code></pre>
<h1 id="生命周期">生命周期</h1>
<h2 id="生命周期图示">生命周期图示</h2>
<p><img src="./assets/note-vue/lifecycle.png" alt="生命周期图示"></p>
<h2 id="生命周期钩子">生命周期钩子</h2>
<p>每个 Vue 实例在被创建时都要经过一系列的初始化过程：设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。<br>
同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</p>
<h3 id="beforecreate">beforeCreate</h3>
<p>在实例初始化之后，数据观测（data observer）和 event / watcher 事件配置之前被调用。</p>
<h3 id="created">created</h3>
<p>在实例创建完成后被立即调用。<br>
在这一步，实例已完成以下的配置：</p>
<ul>
<li>数据观测（data observer）</li>
<li>property 和方法的运算</li>
<li>watch / event 事件回调</li>
</ul>
<p>然而，挂载阶段还没开始，<code>$el</code> property 目前尚不可用。</p>
<h3 id="beforemount">beforeMount</h3>
<p>在挂载开始之前被调用：相关的 render 函数首次被调用。<br>
该钩子在服务器端渲染期间不被调用。</p>
<h3 id="mounted">mounted</h3>
<p>实例被挂载后调用，这时 <code>el</code> 被新创建的 <code>vm.$el </code>替换了。<br>
如果根实例挂载到了一个文档内的元素上，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</p>
<p>注意：</p>
<ul>
<li>
<p><code>mounted</code> 不会保证所有的子组件也都一起被挂载。</p>
</li>
<li>
<p>如果希望等到整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <code>vm.$nextTick</code>：</p>
<pre><code class="language-javascript"><div>mounted: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        ...
    });
}
</div></code></pre>
</li>
</ul>
<blockquote>
<p>该钩子在服务器端渲染期间不被调用。</p>
</blockquote>
<h3 id="beforeupdate">beforeUpdate</h3>
<p>数据更新时调用，发生在虚拟 DOM 打补丁之前。<br>
这里适合在更新之前访问现有的 DOM（例如手动移除已添加的事件监听器）。</p>
<blockquote>
<p>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</p>
</blockquote>
<h3 id="updated">updated</h3>
<p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<br>
当这个钩子被调用时，组件 DOM 已经更新，所以现在可以执行依赖于 DOM 的操作。<br>
然而在大多数情况下，应该避免在此期间更改状态。<br>
如果要相应状态改变，通常最好使用 <code>计算属性</code> 或 <code>watcher</code> 取而代之。</p>
<p>注意：</p>
<ul>
<li>
<p><code>updated</code> 不会保证所有的子组件也都一起被重绘。</p>
</li>
<li>
<p>如果希望等到整个视图都重绘完毕，可以在 <code>updated</code> 内部使用 <code>vm.$nextTick</code>：</p>
<pre><code class="language-javascript"><div>updated: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
   <span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
       ...
   });
}
</div></code></pre>
</li>
</ul>
<blockquote>
<p>该钩子在服务器端渲染期间不被调用。</p>
</blockquote>
<h3 id="beforedestroy">beforeDestroy</h3>
<p>被 <code>keep-alive</code> 缓存的组件激活时调用。</p>
<blockquote>
<p>该钩子在服务器端渲染期间不被调用。</p>
</blockquote>
<h3 id="destroyed">destroyed</h3>
<p>被 <code>keep-alive</code> 缓存的组件停用时调用。</p>
<blockquote>
<p>该钩子在服务器端渲染期间不被调用。</p>
</blockquote>
<h3 id="注意-6">注意</h3>
<p>不要在选项 <code>property</code> 或回调上使用箭头函数，例如：</p>
<pre><code class="language-javascript"><div>created: <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);
}
</div></code></pre>
<pre><code class="language-javascript"><div>vm.$watch(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-function"><span class="hljs-params">newValue</span> =&gt;</span> <span class="hljs-built_in">this</span>.myMethod());
</div></code></pre>
<p>因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，<br>
经常导致 <code>Uncaught TypeError: Cannot read property of undefined</code><br>
或 <code>Uncaught TypeError: this.myMethod is not a function</code> 之类的错误。</p>
<h1 id="vue-cli-脚手架">Vue CLI（脚手架）</h1>
<h2 id="简介-12">简介</h2>
<p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供：</p>
<ul>
<li>通过 <code>@vue/cli</code> 实现的交互式的项目脚手架。</li>
<li>通过 <code>@vue/cli</code> + <code>@vue/cli-service-global</code> 实现的零配置原型开发。</li>
<li>一个运行时依赖 (<code>@vue/cli-service</code>)，该依赖：
<ul>
<li>可升级；</li>
<li>基于 webpack 构建，并带有合理的默认配置；</li>
<li>可以通过项目内的配置文件进行配置；</li>
<li>可以通过插件进行扩展。</li>
</ul>
</li>
<li>一个丰富的官方插件集合，集成了前端生态中最好的工具。</li>
<li>一套完全图形化的创建和管理 Vue.js 项目的用户界面。</li>
</ul>
<p>Vue CLI 致力于将 Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。与此同时，它也为每个工具提供了调整配置的灵活性，无需 eject。</p>
<h2 id="相关链接">相关链接</h2>
<ul>
<li><a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></li>
</ul>
<h2 id="配置-webpack">配置 webpack</h2>
<h3 id="代理服务器">代理服务器</h3>
<pre><code class="language-javascript"><div><span class="hljs-built_in">module</span>.exports = {
    <span class="hljs-comment">// 配置 webpack</span>
    <span class="hljs-attr">configureWebpack</span>: {
        <span class="hljs-comment">// 配置开发服务器</span>
        <span class="hljs-attr">devServer</span>: {
            <span class="hljs-comment">// 配置代理</span>
            <span class="hljs-attr">proxy</span>: {
                <span class="hljs-comment">// 请求路径</span>
                <span class="hljs-string">&#x27;/example/a&#x27;</span>: {
                    <span class="hljs-comment">// 实际请求的服务器根地址</span>
                    <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;https://example.com&#x27;</span>,
                    <span class="hljs-comment">// 是否修改 origin（解决跨域）</span>
                    <span class="hljs-attr">changeorigin</span>: <span class="hljs-literal">true</span>
                }
            }
        }
    }
}
</div></code></pre>
<h1 id="vue-router-路由">Vue Router（路由）</h1>
<h2 id="相关链接-1">相关链接</h2>
<ul>
<li><a href="https://cn.vuejs.org/v2/guide/routing.html">https://cn.vuejs.org/v2/guide/routing.html</a></li>
<li><a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></li>
</ul>
<h2 id="安装">安装</h2>
<h3 id="直接下载-cdn">直接下载 / CDN</h3>
<ul>
<li>
<p><code>https://unpkg.com/vue-router/dist/vue-router.js</code></p>
</li>
<li>
<p>在 <code>Vue</code> 后面加载 <code>vue-router</code></p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/path/to/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/path/to/vue-router.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</div></code></pre>
</li>
</ul>
<h3 id="npm">NPM</h3>
<ul>
<li><code>npm install vue-router</code></li>
</ul>
<h3 id="注意-7">注意</h3>
<p>如果在一个模块化工程中使用它，必须要通过 <code>Vue.use()</code> 明确地安装路由功能：</p>
<pre><code class="language-javascript"><div><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>；
<span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>；

Vue.use(VueRouter)；
</div></code></pre>
<p>如果使用全局的 <code>script</code> 标签，则不需要进行该操作。</p>
<h2 id="配置">配置</h2>
<h3 id="router-index-js">router/index.js</h3>
<h4 id="例子-3">例子</h4>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 导入 Vue</span>
<span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;
<span class="hljs-comment">// 导入 VueRouter</span>
<span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;
<span class="hljs-comment">// 导入组件</span>
<span class="hljs-comment">// @ 表示 /src</span>
<span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/pages/Home.vue&#x27;</span>;

<span class="hljs-comment">// 使用 VueRouter 插件</span>
Vue.use(VueRouter);

<span class="hljs-comment">// 路由节点</span>
<span class="hljs-keyword">const</span> routes = [
    {
        <span class="hljs-comment">// 路由路径标记（匹配字符串，以 / 开头）</span>
        <span class="hljs-comment">// string</span>
        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,
        <span class="hljs-comment">// 当前路由匹配时显示的路由组件</span>
        <span class="hljs-comment">// Component</span>
        <span class="hljs-attr">component</span>: Example,
        <span class="hljs-comment">// 路由名称，设置为具名路由</span>
        <span class="hljs-comment">// string，可选</span>
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,
        <span class="hljs-comment">// 路由重定向</span>
        <span class="hljs-comment">// string | Location | Function，可选</span>
        <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;&#x27;</span>,
        <span class="hljs-comment">// 路由组件传参</span>
        <span class="hljs-comment">// boolean | Object | Function，默认值为 false，可选</span>
        <span class="hljs-attr">props</span>: <span class="hljs-string">&#x27;&#x27;</span>,
        <span class="hljs-comment">// 路由别名</span>
        <span class="hljs-comment">// string | Array &lt; string &gt;，可选</span>
        <span class="hljs-attr">alias</span>: <span class="hljs-string">&#x27;&#x27;</span>,
        <span class="hljs-comment">// 嵌套路由</span>
        <span class="hljs-comment">// Array &lt; RouteConfig &gt;，可选</span>
        <span class="hljs-attr">children</span>: [],
        <span class="hljs-comment">// 路由守卫</span>
        <span class="hljs-comment">// 可选</span>
        <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to: Route, <span class="hljs-keyword">from</span>: Route, next: <span class="hljs-built_in">Function</span></span>) =&gt;</span> <span class="hljs-keyword">void</span>,
        <span class="hljs-comment">// 匹配规则是否大小写敏感</span>
        <span class="hljs-comment">// boolean，默认值为 false，可选</span>
        <span class="hljs-attr">caseSensitive</span>: <span class="hljs-literal">false</span>
    },
    {
        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Default&#x27;</span>,
        <span class="hljs-attr">component</span>: Home
    },
    {
        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span>,
        <span class="hljs-attr">component</span>: Home
    },
    {
        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;About&#x27;</span>,
        <span class="hljs-comment">// 导入并使用组件</span>
        <span class="hljs-comment">// 代码拆分方式，会为此路由生成一个独立的 chunk 文件（about.[hash].js）</span>
        <span class="hljs-comment">// 访问时使用 lazy-loaded 加载方式</span>
        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="hljs-string">&#x27;../pages/About.vue&#x27;</span>)
    }
];

<span class="hljs-comment">// 创建路由对象</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter({
    routes,
    <span class="hljs-comment">// 模式</span>
    <span class="hljs-comment">// hash：默认，使用锚标记（#），刷新后可保持</span>
    <span class="hljs-comment">// history：使用 BOM 对象 history</span>
    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;hash&#x27;</span>,
    <span class="hljs-comment">// 全局设置匹配路由时（匹配一部分即可）的链接标签类名</span>
    <span class="hljs-attr">linkActiveClass</span>: <span class="hljs-string">&#x27;router-link-active&#x27;</span>,
    <span class="hljs-comment">// 全局设置匹配路由时（需要全匹配）的链接标签类名</span>
    <span class="hljs-attr">linkExactActiveClass</span>: <span class="hljs-string">&#x27;router-link-extract-active&#x27;</span>
});

<span class="hljs-comment">// 导出</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;
</div></code></pre>
<h3 id="动态路由匹配">动态路由匹配</h3>
<blockquote>
<p><a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html">https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html</a></p>
</blockquote>
<p>有时候需要把某种模式匹配到的所有路由，全都映射到相同的组件中。<br>
例如：有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。<br>
那么，可以在 vue-router 的路由路径中使用“动态路径参数”（dynamic segment）来达到这个效果：</p>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> User = {
    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;User&lt;/div&gt;&#x27;</span>
};

<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter({
    <span class="hljs-attr">routes</span>: [
        {
            <span class="hljs-comment">// 动态路径参数，以冒号开头</span>
            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>,
            <span class="hljs-attr">component</span>: User
        }
    ];
});
</div></code></pre>
<p>之后，<code>/user/*</code> 都会映射到相同的路由（例如 <code>/user/foo</code>、<code>/user/bar</code>）。</p>
<p>一个“路径参数”使用冒号 <code>:</code> 标记。<br>
当匹配到一个路由时，参数值会被设置到 <code>this.$route.params</code>，可以在每个组件内使用。<br>
因此可以通过以下方法输出当前用户的 ID：</p>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> User = {
    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;User ID: {{ $route.params.id }}&lt;/div&gt;&#x27;</span>
};
</div></code></pre>
<h3 id="重定向-redirect-和别名-alias">重定向（redirect）和别名（alias）</h3>
<blockquote>
<p><a href="https://router.vuejs.org/zh/guide/essentials/redirect-and-alias.html">https://router.vuejs.org/zh/guide/essentials/redirect-and-alias.html</a></p>
</blockquote>
<h3 id="路由组件传参-props">路由组件传参（props）</h3>
<blockquote>
<p><a href="https://router.vuejs.org/zh/guide/essentials/passing-props.html">https://router.vuejs.org/zh/guide/essentials/passing-props.html</a></p>
</blockquote>
<h4 id="布尔模式">布尔模式</h4>
<h4 id="对象模式">对象模式</h4>
<h4 id="函数模式">函数模式</h4>
<h3 id="嵌套路由-children">嵌套路由（children）</h3>
<blockquote>
<p><a href="https://router.vuejs.org/zh/guide/essentials/nested-routes.html">https://router.vuejs.org/zh/guide/essentials/nested-routes.html</a></p>
</blockquote>
<h2 id="router-link">router-link</h2>
<h3 id="to-属性">to 属性</h3>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;{ ... }&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
</div></code></pre>
<pre><code class="language-javascript"><div>{
    <span class="hljs-comment">// 要跳转到的锚标记路径</span>
    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;&#x27;</span>,
    <span class="hljs-comment">// 要跳转到的具名路由名称</span>
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,
    <span class="hljs-comment">// 锚标记</span>
    <span class="hljs-attr">hash</span>: <span class="hljs-string">&#x27;&#x27;</span>,
    <span class="hljs-comment">// 通过 GET 方式方式传递参数</span>
    <span class="hljs-attr">query</span>: {
        属性名: 属性值,
        属性名: 属性值,
        ...
    },
    <span class="hljs-comment">// 通过路由传递参数（需要 name）</span>
    <span class="hljs-comment">// 刷新后会丢失</span>
    <span class="hljs-attr">params</span>: {
        属性名: 属性值,
        属性名: 属性值,
        ...
    }
}
</div></code></pre>
<h3 id="replace-属性">replace 属性</h3>
<ul>
<li>默认值为 <code>false</code></li>
<li>属性值为 <code>true</code> 时，路由的跳转将以替换的形式跳转到下一个页面<br>
（下一个路由会把当前浏览器历史记录栈中的 URL 替换成将要跳转的路由）</li>
</ul>
<h3 id="append-属性">append 属性</h3>
<ul>
<li>默认值为 <code>false</code></li>
<li>属性值为 <code>true</code> 时，若当前路由是相对路径（开头没有 <code>/</code>）路由的跳转将会基于当前路径进行下一级的跳转（附加）</li>
</ul>
<h3 id="tag-属性">tag 属性</h3>
<ul>
<li>默认值为 <code>a</code></li>
<li>指定该 <code>router-link</code> 标签渲染时的 DOM 元素</li>
</ul>
<h3 id="active-class-属性">active-class 属性</h3>
<ul>
<li>设置匹配路由时（匹配一部分即可），<code>router-link</code> 的类名。</li>
</ul>
<h3 id="exact-active-class-属性">exact-active-class 属性</h3>
<ul>
<li>设置匹配路由时（需要全匹配），<code>router-link</code> 的类名。</li>
</ul>
<h3 id="exact-属性">exact 属性</h3>
<ul>
<li>默认值为 <code>false</code></li>
<li>指定当前 <code>router-link</code> 元素使用严格匹配<br>
此时 <code>active-class</code> 只能在严格匹配的模式下被激活</li>
</ul>
<h3 id="event-属性">event 属性</h3>
<ul>
<li>默认值为 <code>click</code></li>
<li>指定可以用来触发当前 <code>router-link</code> 元素导航事件的事件<br>
可以是一个字符串，也可以是一个字符串数组</li>
</ul>
<h3 id="接收数据">接收数据</h3>
<ul>
<li><code>this.$route.query</code>（接收 <code>to - query</code>）</li>
<li><code>this.$route.params</code>（接收 <code>to - params</code>）</li>
<li>组件 <code>props</code>（接收 <code>to - params</code>）</li>
</ul>
<blockquote>
<p>注意：<br>
<code>$route</code> - 当前路由对象<br>
<code>$router</code> - 全局路由对象</p>
</blockquote>
<h2 id="router-view">router-view</h2>
<p>当路由路由路径发生改变时，根据当前 VueRouter 的配置渲染对应的路由视图组件。<br>
<code>router-view</code> 组件是一个 <code>functional</code> 组件，渲染路径匹配到的视图组件。<br>
<code>router-view</code> 渲染的组件还可以内嵌自己的 <code>router-view</code>，根据嵌套路径，渲染嵌套组件。<br>
其他属性（除 <code>name</code> 以外的非 <code>router-view</code> 使用的属性）都可以直接传给渲染的组件，很多时候，每个路由的数据都包含在路由参数中。<br>
因为它是个组件，所以也可以配合 <code>&lt;transition&gt;</code> 和 <code>&lt;keep-alive&gt;</code> 使用（如果两个结合一起用，要确保在内层使用 <code>&lt;keep-alive&gt;</code>）。</p>

    </body>
    </html>